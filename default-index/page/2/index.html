<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"livere","storage":true,"lazyload":false,"nav":null,"activeClass":"livere"},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="Here we go!!!!">
<meta property="og:type" content="website">
<meta property="og:title" content="Here We Go">
<meta property="og:url" content="http://example.com/default-index/page/2/index.html">
<meta property="og:site_name" content="Here We Go">
<meta property="og:description" content="Here we go!!!!">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="LLCH Liu">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/default-index/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Here We Go</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Here We Go</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/home/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-resources">

    <a href="/resources/" rel="section"><i class="download fa-fw"></i>resources</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/09/14/JVM/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="LLCH Liu">
      <meta itemprop="description" content="Here we go!!!!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Here We Go">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/09/14/JVM/" class="post-title-link" itemprop="url">JVM-内存结构及垃圾回收</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-09-14 20:35:51" itemprop="dateCreated datePublished" datetime="2023-09-14T20:35:51+08:00">2023-09-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-09-21 12:12:14" itemprop="dateModified" datetime="2023-09-21T12:12:14+08:00">2023-09-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JVM/" itemprop="url" rel="index"><span itemprop="name">-JVM</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="什么是JVM"><a href="#什么是JVM" class="headerlink" title="什么是JVM?"></a>什么是JVM?</h2><p><strong>Java Virtual Machine</strong> - java程序的运行环境（Java 二进制字节码的运行环境）</p>
<p>屏蔽Java代码与底层操作系统的差异</p>
<ul>
<li>对外提供一致的运行环境（平台无关性）</li>
<li>自动内存管理，垃圾回收功能</li>
<li>数组下标越界检查（抛异常比新元素覆盖程序其他部分强）</li>
<li>多态</li>
</ul>
<p><strong>JRE</strong> :        JVM+基础类库（日期类等等IO类）</p>
<p>**JDK ** :      JVM+编译工具（javac,  Javap，内存检测工具等等）</p>
<p><strong>开发JavaSE程序</strong>：   JDK + IDE工具</p>
<p><strong>开发JavaEE程序</strong>：   JDK+IDE工具+应用服务器（tomcat)</p>
<h2 id="JVM组成"><a href="#JVM组成" class="headerlink" title="JVM组成:"></a>JVM组成:</h2><p><img src="/filename/1.png" alt="https://github.com/LiuLCH1014/LiuLCH1014.github.io/blob/main/filename/1.png"></p>
<p>java源代码编译为二进制字节码以后(Java class),经过类加载器(classLoader),才能加载到JVM内存结构中被运行。</p>
<p>类都是放在方法区，类创建的实例对象放在堆，实例对象调用方法时用到虚拟机栈等</p>
<p>方法执行时由执行引擎中的解释器逐行解释，即时编译器优化执行频繁调用的代码。</p>
<p>GC会对堆中不再引用的对象垃圾回收。</p>
<p>Java代码中不方便实现的功能，本地接口调用本地操作系统提供的功能方法</p>
<hr>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><h4 id="垃圾回收是否涉及栈内存？"><a href="#垃圾回收是否涉及栈内存？" class="headerlink" title="垃圾回收是否涉及栈内存？"></a>垃圾回收是否涉及栈内存？</h4><p>栈自动出栈，不需要垃圾回收管理栈内存</p>
<h4 id="栈内存分配越大越好吗"><a href="#栈内存分配越大越好吗" class="headerlink" title="栈内存分配越大越好吗"></a>栈内存分配越大越好吗</h4><p>栈越大，线程数越少</p>
<h4 id="方法内的局部变量是否线程安全"><a href="#方法内的局部变量是否线程安全" class="headerlink" title="方法内的局部变量是否线程安全-"></a>方法内的局部变量是否线程安全-</h4><p>这要看这个变量是对每个线程共享的，还是每个线程私有的。共享的不用考虑线程安全。</p>
<p>如果是static，<strong>静态变量属于类</strong>，放在方法区，属于线程共享的数据。</p>
<p>StringBuilder本来就不是线程安全的，如果用StringBuffer就是线程安全的。</p>
<p>是不是线程安全不仅要看是否是方法内的局部变量，也要看是否逃离方法的作用范围。</p>
<h4 id="栈—内存溢出"><a href="#栈—内存溢出" class="headerlink" title="栈—内存溢出"></a>栈—内存溢出</h4><ul>
<li>线程请求的栈深度大于虚拟机所允许的最大深度，抛出StackOverflowError</li>
<li>虚拟机的栈内存如果允许动态扩展，当栈容量无法申请到足够的内存抛出 OutOfMemoryError</li>
</ul>
<hr>
<h2 id="JVM内存结构"><a href="#JVM内存结构" class="headerlink" title="JVM内存结构"></a>JVM内存结构</h2><h3 id="程序计数器——Program-Counter-Register"><a href="#程序计数器——Program-Counter-Register" class="headerlink" title="程序计数器——Program Counter Register"></a>程序计数器——Program Counter Register</h3><p>记住下一条<strong>jvm指令</strong>的执行地址（寄存器）</p>
<ul>
<li><strong>线程私有</strong>  每个线程都有自己的register</li>
<li>不会存在内存溢出</li>
</ul>
<hr>
<h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>线程运行需要的内存空间</p>
<p>不指定大小Linux，Oracle，macSO都是<strong>1024k</strong></p>
<p>windows会根据虚拟内存影响栈的大小</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-Xss size</span><br><span class="line"></span><br><span class="line">//example</span><br><span class="line">-Xss 1m</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="栈帧"><a href="#栈帧" class="headerlink" title="栈帧"></a>栈帧</h4><p><em><strong>每个方法需要的内存</strong></em>（参数，局部变量，返回地址）</p>
<hr>
<h4 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h4><p>用c和c++编写的本地方法，来真正与操作系统和本地API打交道，可以间接使用本地方法，这些本地方法使用的栈就是本地方法栈。</p>
<p>native方法有C&#x2F;C++底层实现。</p>
<p>当调用本地方法时程序计数器为空。</p>
<hr>
<h3 id="Heap-堆"><a href="#Heap-堆" class="headerlink" title="Heap 堆"></a>Heap 堆</h3><p>   通过<strong>new</strong>关键字，创建对象都会使用堆内存</p>
<ul>
<li>它是线程共享的，堆中对象都需要考虑线程安全问题</li>
<li>有垃圾回收机制</li>
</ul>
<hr>
<h4 id="堆内存溢出诊断"><a href="#堆内存溢出诊断" class="headerlink" title="堆内存溢出诊断"></a>堆内存溢出诊断</h4><p>可以通过<strong>反编译</strong><code>javac xxx.java</code>来查看类的信息</p>
<ul>
<li><p>jps工具</p>
<p>查看当前系统哪些java进程</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jps</span><br></pre></td></tr></table></figure>


</li>
<li><p>jmap工具</p>
<p>查看堆内存占用情况，只能查看某一时刻的状态</p>
<p>Heap Configuration:堆的设置</p>
<p>Heap Usage &#x2F; Eden Space &#x2F;used：查看占用内存</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmap -heap 进程id</span><br></pre></td></tr></table></figure>
</li>
<li><p>jconsole工具</p>
<p>图形界面工具，可以连续监测</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jconsole</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h4><h5 id="垃圾回收后内存过高"><a href="#垃圾回收后内存过高" class="headerlink" title="垃圾回收后内存过高"></a>垃圾回收后内存过高</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jvisualvm</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="方法区-Method-Area"><a href="#方法区-Method-Area" class="headerlink" title="方法区-Method Area"></a>方法区-Method Area</h3><p>会受到内存限制，抛出<strong>OutOfMemoryError</strong>异常</p>
<p><img src="/filename/2.png" alt="https://github.com/LiuLCH1014/LiuLCH1014.github.io/blob/main/filename/2.png"></p>
<p>方法区是所有java虚拟机线程的<strong>共享</strong>的区，用于存储已被虚拟机加载的类型信息，常量，静态变量，即时编译器编译后的代码缓存等数据</p>
<p>JDK1.8版本之前方法区用的堆的内存，叫<strong>永久代</strong>，JDK1.8之后用的操作系统的内存，叫<strong>元空间</strong>。</p>
<p>元空间被在本地内存中</p>
<p>永久代是方法区的实现，方法区也是一种规范，具体的实现是永久代和元空间，不同的厂商实现方式不同</p>
<h3 id="运行时常量池-Runtime-Constant-Pool"><a href="#运行时常量池-Runtime-Constant-Pool" class="headerlink" title="运行时常量池-Runtime Constant Pool"></a>运行时常量池-Runtime Constant Pool</h3><p>常量池表（存放编译时期生成的字面量和符号引用）在类加载后存放到方法区的运行时常量池中。</p>
<p>动态性   Java语言并不要求常量编译时产生，运行期间也可以将新的常量放入池中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string1.intern();</span><br></pre></td></tr></table></figure>

<p>intern方法，主动将<strong>串池中还没有的字符串对象</strong>放入串池，</p>
<p>将字符串对象s1尝试放入串池，<strong>如果原来存在有并不会放入</strong>，<strong>还会在堆中</strong>，如果没有则放入串池，会把串池的对象返回。</p>
<h3 id="StringTable"><a href="#StringTable" class="headerlink" title="StringTable"></a>StringTable</h3><p>stringtable是串池，<strong>串池是常量池中的一部分</strong>。</p>
<p>垃圾回收不会发生在永久代(PermGen space)，如果永久代满了或者是超过了临界值，会触发完全垃圾回收(Full GC)。</p>
<h4 id="stringTable性能调优"><a href="#stringTable性能调优" class="headerlink" title="stringTable性能调优"></a>stringTable性能调优</h4><ul>
<li><p>主要调整hashTable桶的个数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:SringTableSize=×××</span><br></pre></td></tr></table></figure>
</li>
<li><p>考虑字符串对象是否入池</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//example</span></span><br><span class="line">intern();</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itcast.itheima.xpp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        String s1=<span class="string">&quot;a&quot;</span>;</span><br><span class="line">        String s2=<span class="string">&quot;b&quot;</span>;</span><br><span class="line">        String s3=<span class="string">&quot;a&quot;</span>+<span class="string">&quot;b&quot;</span>;</span><br><span class="line">        String s4=s1+s2;</span><br><span class="line">        String s5=<span class="string">&quot;ab&quot;</span>;</span><br><span class="line">        String s6=s4.intern();</span><br><span class="line">        System.out.println(s3==s4);<span class="comment">//false</span></span><br><span class="line">        System.out.println(s3==s5);<span class="comment">//true</span></span><br><span class="line">        System.out.println(s3==s6);<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">        String x2=<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;c&quot;</span>)+<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;d&quot;</span>);</span><br><span class="line">        String x1=<span class="string">&quot;cd&quot;</span>;</span><br><span class="line">        x2.intern();</span><br><span class="line">        System.out.println(x1==x2);<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        String x4=<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;e&quot;</span>)+<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;f&quot;</span>);</span><br><span class="line">        x4.intern();</span><br><span class="line">        String x3=<span class="string">&quot;ef&quot;</span>;</span><br><span class="line">        System.out.println(x3==x4);<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h3><p>这部分被频繁引用，也会导致<strong>OutOfMemoryError</strong></p>
<p>一般配置虚拟机参数，会根据实际内存去设置-Xmx等参数信息，但经常忽略直接内存，从而导致动态扩展出现OutOfMemoeryError。</p>
<p>NIO类引入了一种基于通道与缓存区的I&#x2F;O方式，可以使用Native函数库直接分配<strong>堆外内存</strong>，通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。<strong>避免了在Java堆和Native堆中来回复制</strong>。</p>
<p><img src="/filename/3.png" alt="https://github.com/LiuLCH1014/LiuLCH1014.github.io/blob/main/filename/3.png"></p>
<p>通过两次缓冲区，效率不高</p>
<hr>
<h4 id="直接内存回收原理"><a href="#直接内存回收原理" class="headerlink" title="直接内存回收原理"></a>直接内存回收原理</h4><ul>
<li>使用了 Unsafe 类来完成直接内存的分配回收，回收需要主动调用<code>freeMemory</code> 方法</li>
<li>ByteBuffer 的实现内部使用了 Cleaner（虚引用）来检测 ByteBuffer 。一旦ByteBuffer 被垃圾回收，那么会由 ReferenceHandler（守护线程） 来调用 <code>Cleaner.clean</code> 方法调用 <strong>freeMemory</strong> 来释放内存</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Code_06_DirectMemoryTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">_1GB</span> <span class="operator">=</span> <span class="number">1024</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, NoSuchFieldException, IllegalAccessException &#123;</span><br><span class="line"><span class="comment">//        method();</span></span><br><span class="line">        method1();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 演示 直接内存 是被 unsafe 创建与回收</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span> <span class="keyword">throws</span> IOException, NoSuchFieldException, IllegalAccessException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> Unsafe.class.getDeclaredField(<span class="string">&quot;theUnsafe&quot;</span>);</span><br><span class="line">        field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">Unsafe</span> <span class="variable">unsafe</span> <span class="operator">=</span> (Unsafe)field.get(Unsafe.class);</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">base</span> <span class="operator">=</span> unsafe.allocateMemory(_1GB);</span><br><span class="line">        unsafe.setMemory(base,_1GB, (<span class="type">byte</span>)<span class="number">0</span>);</span><br><span class="line">        System.in.read();</span><br><span class="line"></span><br><span class="line">        unsafe.freeMemory(base);</span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 演示 直接内存被 释放</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">byteBuffer</span> <span class="operator">=</span> ByteBuffer.allocateDirect(_1GB);</span><br><span class="line">        System.out.println(<span class="string">&quot;分配完毕&quot;</span>);</span><br><span class="line">        System.in.read();</span><br><span class="line">        System.out.println(<span class="string">&quot;开始释放&quot;</span>);</span><br><span class="line">        byteBuffer = <span class="literal">null</span>;</span><br><span class="line">        System.gc(); <span class="comment">// 手动 gc</span></span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>直接内存的回收不是通过 JVM 的垃圾回收来释放的，而是通过<code>unsafe.freeMemory</code> 来手动释放。</strong><br>第一步：allocateDirect 的实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ByteBuffer <span class="title function_">allocateDirect</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DirectByteBuffer</span>(capacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>底层是创建了一个 DirectByteBuffer 对象。<br>第二步：DirectByteBuffer 类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">DirectByteBuffer(<span class="type">int</span> cap) &#123;   <span class="comment">// package-private</span></span><br><span class="line">   </span><br><span class="line">    <span class="built_in">super</span>(-<span class="number">1</span>, <span class="number">0</span>, cap, cap);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">pa</span> <span class="operator">=</span> VM.isDirectMemoryPageAligned();</span><br><span class="line">    <span class="type">int</span> <span class="variable">ps</span> <span class="operator">=</span> Bits.pageSize();</span><br><span class="line">    <span class="type">long</span> <span class="variable">size</span> <span class="operator">=</span> Math.max(<span class="number">1L</span>, (<span class="type">long</span>)cap + (pa ? ps : <span class="number">0</span>));</span><br><span class="line">    Bits.reserveMemory(size, cap);</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="variable">base</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        base = unsafe.allocateMemory(size); <span class="comment">// 申请内存</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (OutOfMemoryError x) &#123;</span><br><span class="line">        Bits.unreserveMemory(size, cap);</span><br><span class="line">        <span class="keyword">throw</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    unsafe.setMemory(base, size, (<span class="type">byte</span>) <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (pa &amp;&amp; (base % ps != <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="comment">// Round up to page boundary</span></span><br><span class="line">        address = base + ps - (base &amp; (ps - <span class="number">1</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        address = base;</span><br><span class="line">    &#125;</span><br><span class="line">    cleaner = Cleaner.create(<span class="built_in">this</span>, <span class="keyword">new</span> <span class="title class_">Deallocator</span>(base, size, cap)); <span class="comment">// 通过虚引用，来实现直接内存的释放，this为虚引用的实际对象, 第二个参数是一个回调，实现了 runnable 接口，run 方法中通过 unsafe 释放内存。</span></span><br><span class="line">    att = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里调用了一个 <code>Cleaner .create</code> 方法，且后台线程还会对虚引用的对象监测，<em>如果虚引用的实际对象（这里是 DirectByteBuffer ）被回收以后，就会调用 Cleaner 的 clean 方法，来清除直接内存中占用的内存。</em></p>
<p>jvm调优常用参数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+DisableExplicitGC  // 静止显示的 GC</span><br></pre></td></tr></table></figure>

<p>意思就是禁止我们手动的 GC，比如手动 System.gc() 无效，它是一种 full gc，会回收新生代、老年代，会造成程序执行的时间比较长。所以我们就通过 unsafe 对象调用 freeMemory 的方式释放内存。</p>
<hr>
<h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><p><strong>程序计数器、虚拟机栈、本地方法栈</strong>三个区域随线程生灭。这几个区域的内存分配和回收都具备确定性，方法结束、线程结束，自然回收。</p>
<p>Java堆和方法区就有不确定性。只有在运行期间才知道创建哪些对象，分配和回收具有动态性。</p>
<hr>
<h3 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h3><blockquote>
<p><em>本博客不特别记录引用计数法</em></p>
</blockquote>
<p>可作为GC Root的对象</p>
<ul>
<li><p>虚拟机栈（<strong>栈帧中的本地变量表</strong>）中引用的对象，当前正在运行的方法所用到的参数、局部变量、临时变量。</p>
</li>
<li><p>方法区中类<strong>静态</strong>属性引用的对象，如Java类的<strong>引用类型静态变量</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private static User user1；</span><br></pre></td></tr></table></figure>
</li>
<li><p>方法区中<strong>常量</strong>引用的对象，比如字符串常量池（StringTable）里的引用，<strong>final</strong> 修饰。</p>
</li>
<li><p>本地方法栈中 JNI（即一般说的<strong>Native方法</strong>）引用的对象。</p>
</li>
<li><p>Java 虚拟机内部的引用，如基本数据类型对应的 Class 对象，一些常驻的异常对象(比如 NullPointExcepiton、Out Of MemoryError)等，还有系统类加载器。</p>
</li>
<li><p>所有被同步锁(synchronized 关键字)持有的对象。</p>
</li>
<li><p>反映 Java 虚拟机内部情况的 JMXBean、JVMTI 中注册的回调、本地代码缓存等</p>
</li>
</ul>
<hr>
<h3 id="四种引用"><a href="#四种引用" class="headerlink" title="四种引用"></a>四种引用</h3><ul>
<li><p>强引用是最传统的“引用”的定义，是指在程序代码之中<strong>普遍存在</strong>的引用赋值。无论任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object obj=<span class="keyword">new</span> <span class="title class_">Object</span>()</span><br></pre></td></tr></table></figure>
</li>
<li><p>软引用是用来描述一些还有用，但非必须的对象。只被软引用关联着的对象，<u>在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存，才会抛出内存溢出异常。</u>在 JDK 1.2 版之后提供了 <code>SoftReference</code> 类来实现软引用。</p>
</li>
<li><p>弱引用也是用来描述那些非必须对象，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生为止。当垃圾收集器开始工作，<u>无论当前内存是否足够，都会回收掉只被弱引用关联的对象。</u>在 JDK 1.2 版之后提供了 <code>WeakReference</code> 类来实现弱引用。</p>
</li>
<li><p>虚引用也称为“幽灵引用”或者“幻影引用”，它是最弱的一种引用关系。必须配合<strong>引用队列</strong>使用，主要配合 <strong><code>ByteBuffer</code></strong> 使用，被<strong>引用对象回收时</strong>，会将<strong>虚引用</strong>入队， 由 <strong>Reference Handler</strong> 线程调用虚引用相关方法(<code>Unsafe.freeMemory</code>)释放<strong>直接内存</strong>。。在 JDK 1.2 版之后提供了 PhantomReference 类来实现虚引用。</p>
</li>
</ul>
<blockquote>
<p><em>本博客不特别记录finallize()</em></p>
</blockquote>
<hr>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 演示 软引用</span></span><br><span class="line"><span class="comment"> * -Xmx20m -XX:+PrintGCDetails -verbose:gc</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Code_08_SoftReferenceTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">_4MB</span> <span class="operator">=</span> <span class="number">4</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        method2();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置 -Xmx20m , 演示堆内存不足,</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        ArrayList&lt;<span class="type">byte</span>[]&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> <span class="title class_">byte</span>[_4MB]);</span><br><span class="line">        &#125;</span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 演示 软引用</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        ArrayList&lt;SoftReference&lt;<span class="type">byte</span>[]&gt;&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            SoftReference&lt;<span class="type">byte</span>[]&gt; ref = <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">byte</span>[_4MB]);</span><br><span class="line">            System.out.println(ref.get());</span><br><span class="line">            list.add(ref);</span><br><span class="line">            System.out.println(list.size());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;循环结束：&quot;</span> + list.size());</span><br><span class="line">        <span class="keyword">for</span>(SoftReference&lt;<span class="type">byte</span>[]&gt; ref : list) &#123;</span><br><span class="line">            System.out.println(ref.get());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><p>method1 方法解析：<br>首先会设置一个堆内存的大小为 20m，然后运行 mehtod1 方法，会抛异常，堆内存不足，因为 mehtod1 中的 list 都是强引用。</p>
</li>
<li><p>method2 方法解析：<br>在 list 集合中存放了 软引用对象，当内存不足时，会触发 full gc，将软引用的对象回收。</p>
</li>
<li><p>method3方法解析：</p>
<p>当软引用引用的对象被回收了，但是软引用还存在，所以，一般软引用需要搭配一个引用队列一起使用。</p>
</li>
</ul>
<p><strong>关联了引用队列，当软引用所关联的 byte[] 被回收时，软引用自己会加入到 queue 中去</strong></p>
<hr>
<h3 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h3><p>商用虚拟机里，设计者一般至少会把Java堆划为新生代和老年代两区域。</p>
<p>新生代中，每次垃圾收集大批死去，回收少量对象，逐步晋升到老年代存放。</p>
<p>以上是对HotSpot虚拟机。在IBM J9虚拟机中称为婴儿区，长生区。</p>
<h4 id="标记清除算法"><a href="#标记清除算法" class="headerlink" title="标记清除算法"></a><strong>标记清除算法</strong></h4><p>首先标记出所有需要回收的对象，标记完成后统一回收所有被标记的对象。</p>
<p>把对象的起始结束地址放在空闲列表中，分配新对象时去找。</p>
<p>缺点：执行效率不稳定，大量的标记和清除动作。<strong>内存空间碎片化</strong>问题，标记清除后大量不连续的内存碎片。</p>
<h4 id="标记整理算法"><a href="#标记整理算法" class="headerlink" title="标记整理算法"></a>标记整理算法</h4><p>所有存活对象都向内存空间一端移动，然后清理边界以外的内存。</p>
<p>然而必须全程暂停用户应用程序。</p>
<h4 id="标记复制算法"><a href="#标记复制算法" class="headerlink" title="标记复制算法"></a>标记复制算法</h4><p>将内存容量划为相等两部分，当这一块内存用完，就将还活着的对象复制到另一块上面。</p>
<p>运行简单，高效。但空间浪费大。</p>
<p>存活率较高时就要进行多次复制操作，效率低。如果不想浪费50%空间，就要有额外的空间担保，以应对内存中所有对象100%存活的情况。</p>
<hr>
<h3 id="分代垃圾回收"><a href="#分代垃圾回收" class="headerlink" title="分代垃圾回收"></a>分代垃圾回收</h3><p><img src="/filename/6.png"></p>
<ul>
<li>新生代空间不足时，触发 <strong>Minor GC</strong>，伊甸园和 from 存活的对象使用 copy 复制到 to 中，存活的对象年龄加 1并且<strong>交换 from 和to</strong>。</li>
<li>再次创建对象，若新生代的伊甸园(eden space)又满了，则会再次触发 Minor GC（<strong>minor gc 会引发 stop the world</strong>，暂停其它用户的线程，等垃圾回收结束，用户线程才恢复运行），这时不仅会回收伊甸园中的垃圾，还会回收幸存区中的垃圾，再将活跃对象复制到幸存区TO中。回收以后会<strong>交换两个幸存区</strong>，并让幸存区中的对象寿命加1。</li>
<li>当对象寿命超过阈值时，会晋升至老年代，最大寿命是<strong>15</strong>（寿命是保存在每个对象的对象头中，存寿命的部分是4bit）。</li>
<li>当老年代空间不足，会先尝试触发<strong>Minor GC</strong>，如果之后空间仍不足，那么触发 <strong>Full GC</strong>，因为老年代存活率一般比较高，stop the world的时间更长。</li>
<li>都不够就会触发OutOfMermory</li>
</ul>
<hr>
<h2 id="GC分析"><a href="#GC分析" class="headerlink" title="GC分析"></a>GC分析</h2><h3 id="相关vm参数"><a href="#相关vm参数" class="headerlink" title="相关vm参数"></a>相关vm参数</h3><table>
<thead>
<tr>
<th align="center">含义</th>
<th align="center">参数</th>
</tr>
</thead>
<tbody><tr>
<td align="center">堆初始大小</td>
<td align="center">-Xms</td>
</tr>
<tr>
<td align="center">堆最大大小</td>
<td align="center">-Xmx或-XX:MaxHeapSize&#x3D;size</td>
</tr>
<tr>
<td align="center">新生代大小</td>
<td align="center">-Xmn 或 (-XX:NewSize&#x3D;size + -XX:MaxNewSize&#x3D;size )</td>
</tr>
<tr>
<td align="center">幸存区比例（动态）</td>
<td align="center">-XX:SurvivorRatio&#x3D;ratio和-XX:+UseAdaptiveSizepolicy</td>
</tr>
<tr>
<td align="center">幸存区比例</td>
<td align="center">-XX:SurvivorRatio&#x3D;ratio</td>
</tr>
<tr>
<td align="center">晋升阈值</td>
<td align="center">-XX:MaxTenuringThreshold&#x3D;threshold</td>
</tr>
<tr>
<td align="center">晋升详情</td>
<td align="center">-XX:+PrintTenuringDistribution</td>
</tr>
<tr>
<td align="center">GC详情</td>
<td align="center">-XX:+PrintGCDetails -verbose:gc</td>
</tr>
<tr>
<td align="center">FullGC 前 MinorGC</td>
<td align="center">XX:+ScavengeBeforeFullGC</td>
</tr>
</tbody></table>
<p>幸村区比例：如果新生代是10M,当ratio&#x3D;8时，有8M是划给伊甸园的。剩下两等分，分给from和to。</p>
<p>某个线程的内存溢出了而抛异常（out of memory），不会让其他的线程结束运行。这是因为当一个线程<strong>抛出OOM异常后</strong>，<strong>它所占据的内存资源会全部被释放掉</strong>，从而不会影响其他线程的运行，<strong>进程依然正常</strong></p>
<hr>
<h3 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h3><p>Serial收集器–&gt;Parallel–&gt;Concurrent Mark Sweep(CMS)和Garbage First(G1)收集器–&gt;Shenandoah和ZGC</p>
<hr>
<h4 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h4><p>单线程工作的收集器，他在垃圾收集时，必须暂停其他所有工作，直到他完成收集。</p>
<p>新生代采用复制算法，老生代采用标记整理算法。</p>
<p><img src="/filename/9.png"></p>
<hr>
<h4 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a><strong>ParNew收集器</strong></h4><p>是Serial收集器的<strong>多线程并行版本</strong>，除使用多线程外基本与Serial收集器基本一致。目前只有它与CMS收集器配合工作。Parnew收集器是激活CMS后（使用<code>-XX:+UseConcMarkSweepGC</code>)的默认新生代收集器。</p>
<p><img src="/filename/10.png"></p>
<p><strong>开启串行回收器</strong>：新生代**-Serial** ，老年代-<strong>SerialOld</strong> ，vm参数：<code>XX:+UseSerialGC = Serial + SerialOld</code></p>
<p><img src="/filename/5.png"></p>
<p><strong>安全点</strong>：让其他线程都在这个点停下来，以免垃圾回收时移动对象地址，使得其他线程找不到被移动的对象。安全点位置的选取基本上是以“<strong>是否具有让程序长时间执行的特征</strong>”为标准 进行选定的,例如方法调用、循环跳转、异常跳转 等都属于指令序列复用，所以只有具有这些功能的指令才会产生安全点。</p>
<p><strong>阻塞</strong>：因为是串行的，所以只有一个垃圾回收线程。且在该线程执行回收工作时，其他线程进入<strong>阻塞</strong>状态。</p>
<hr>
<h4 id="吞吐量优先-Parallel-Scavenge收集器"><a href="#吞吐量优先-Parallel-Scavenge收集器" class="headerlink" title="吞吐量优先(Parallel Scavenge收集器)"></a>吞吐量优先(Parallel Scavenge收集器)</h4><p>多线程，堆内存较大，多核CPU。单位时间内，STW的时间最短。总时间最短。</p>
<p><strong>开启垃圾回收器</strong>：vm参数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseParallelGC~-XX:+UseParalleOldGC</span><br></pre></td></tr></table></figure>

<p>1.8都默认开启前者代表是新生代的垃圾回收器，使用的是复制算法；后者工作在老年代，采用标记整理算法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:ParallelGCThreads=n</span><br></pre></td></tr></table></figure>

<p>控制ParallelGC运行时的线程数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseAdaptiveSizePolicy</span><br></pre></td></tr></table></figure>

<p>新生代自适应大小调整策略</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:GCTimeRatio=ratio</span><br></pre></td></tr></table></figure>

<p>调节垃圾回收时间和总时间的占比。1&#x2F;(ratio+1)，垃圾回收总时间占比</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:MaxGCPauseMillis=ms</span><br></pre></td></tr></table></figure>

<p>每次垃圾回收最大暂停毫秒数</p>
<p><img src="/filename/7.png"></p>
<hr>
<h4 id="响应时间优先（CMS"><a href="#响应时间优先（CMS" class="headerlink" title="响应时间优先（CMS)"></a>响应时间优先（CMS)</h4><p>多线程，-堆内存较大，多核CPU。尽可能让单次STW时间最短。适用于关注响应速度的服务</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseConcMarkSweepGC-XX:+UseParNewGC~SerialOld</span><br></pre></td></tr></table></figure>

<p>基于标记清除算法的垃圾回收器。</p>
<p>导致过度内存碎片,分配对象时MinorGC不足，老年代也不足，导致并发失败，CMSGC退化为SerialOld，单线程串行的垃圾回收。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:ParallelGCThreads=n~-XX:ConGCThreads=threads</span><br></pre></td></tr></table></figure>

<p>前者：并行的垃圾回收线程数，一般跟cpu核数一样。</p>
<p>后者：并发的垃圾回收线程数，一般设为并行线程数的四分之一。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:CMSInitiatingOccupancyFraction=percent</span><br></pre></td></tr></table></figure>

<p>作用：并发清理的时候会产生新的垃圾，不能等到内存不足了才去清理。要预留空间给浮动垃圾。值设置的越小，触发时机越早。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+CMSScavengeBeforceRemark</span><br></pre></td></tr></table></figure>

<p>作用：在重新标记前对新生代的进行垃圾回收，新生代存活对象少，减轻重新标记压力。（+打开，-关闭）</p>
<p><img src="/filename/8.png"></p>
<p>初始标记只会列举根对象，非常快。用户线程就会恢复运行，垃圾回收线程就会并发标记，把剩余垃圾标记。重新标记再次STW，因为在之前那并发标记期间存在新的引用，影响标记。</p>
<hr>
<h4 id="Young-Colletion跨代引用"><a href="#Young-Colletion跨代引用" class="headerlink" title="Young Colletion跨代引用"></a>Young Colletion跨代引用</h4><p>简单叙述：老年代数据比较多，一个个遍历找跟对象很麻烦，那就把是根的对象的用一张卡记录，记录和新生代的关系，这样新生代中找跟对象就直接查卡，减少找寻的时间</p>
<p>采用了cart table的方式，对老年代进行细分，分成了许多个card,每个card大约是512K。如果老年代某个对象，引用了新生代的对象，我们把这个老年代的对象标记为脏card。脏card不会立即更新，会把更新指令放在queue中。0-0-记忆集可以理解为一种规范，卡表理解为一种具体的实现方式，CMS只有唯一一个卡表（新生代维护），G1每个region都必须有一份卡表</p>
<hr>
<h4 id="并发可达性分析"><a href="#并发可达性分析" class="headerlink" title="并发可达性分析"></a>并发可达性分析</h4><p>产生“对象消失”的问题的两个条件</p>
<ul>
<li>赋值器插入了一条或多条从黑色对象到白色对象的引用。</li>
<li>赋值器删除了全部从灰色对象到该白色对象的直接或间接引用。</li>
</ul>
<p>可以通过<strong>增量更新</strong>（Incremental Update）和<strong>原始快照</strong>（Snapshot At The Beginning，SATB）</p>
<p>增量更新破坏的是第一个条件：当黑色对象插入新的指向白色对象的引用关系时，就将这个新插入的引用记录下来，等并发扫描结束后，再将这些记录过引用关系中的黑色对象为根，重新扫描。可理解为黑色对象插入指向白色对象的饮用后，变为灰色。</p>
<p>原始快照破坏第二个条件：当灰色对象要删除指向白色对象的的引用关系时，将这个要删除的引用记录下来，等并发扫描后，再将这些记录过引用关系的灰色对象为根，重新扫描。</p>
<p>引用关系记录的插入还是删除，虚拟机的记录操作都是通过写屏障是实现的。G1、Shenandoah使用原始快照。</p>
<hr>
<p>写屏障</p>
<p>当灰色对象要删除指向白色对象的的引用关系时，就会触发写屏障机制，将这个要删除的引用记录下来写到本地对象中。然后写进全局队列 </p>
<h4 id="Garbage-First收集器"><a href="#Garbage-First收集器" class="headerlink" title="Garbage First收集器"></a>Garbage First收集器</h4><p>在G1收集器出现之前，包括cms在内，垃圾收集器的目标范围要么是新生代（Minor GC），要么是老年代（Major GC)，要么就是整个java堆（Full GC）。而G1可以面向堆内存的任何部分来组成回收集进行回收，衡量标准不再是它属于哪个分代，而是哪块内存存放垃圾最多，回收收益最大，这就是G1的Mixed GC模式。注意：G1仍遵循分代收集理论。</p>
<p>G1的关键基于Region的堆内存布局。G1把连续的堆内存划分为多个大小相等的独立区域（Region)，每个region都可以根据需要成为Eden，Survivor空间，或者是老年代空间。region还存在一类特殊的Humongous区域，专门存储大对象，G1大多数行为把它当作老年代一部分看待。</p>
<blockquote>
<p><strong>Young Collection–&gt;YoungCollection+Concurrent Mark–&gt;Mixed Collection–&gt;Young Collection</strong></p>
</blockquote>
<p><img src="/1.jpg"></p>
<h6 id="Young-Collection"><a href="#Young-Collection" class="headerlink" title="Young Collection"></a>Young Collection</h6><p>新创建的对象一开始放在Eden区域，当逐渐被占满，触发一次垃圾回收（当然和其他一样有<strong>STW</strong>，但比较短），以<strong>copy的算法</strong>放入幸存区。一定情况下（上面已说明）幸存区会触发垃圾回收（部分进入老年代）</p>
<hr>
<h6 id="YoungCollection-Concurrent-Mark"><a href="#YoungCollection-Concurrent-Mark" class="headerlink" title="YoungCollection+Concurrent Mark"></a>YoungCollection+Concurrent Mark</h6><p>在新生代GC时会进行GC Root的初始标记。</p>
<p>老年代占用堆空间达到阈值时，进行并发标记（no STW），vm参数：     <code>-XX:InitiatingHeapOccupancyPercent=percent</code>。</p>
<hr>
<h6 id="Mixed-Collection"><a href="#Mixed-Collection" class="headerlink" title="Mixed Collection"></a>Mixed Collection</h6><p>并发标记后，老年代也要回收，部分老年会通过复制算法复制到新的老年代区（多少取决于设置的暂停时间<code>-XX:MaxGCPauseMillis=ms</code>)。</p>
<hr>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/09/12/%E5%85%AB%E8%82%A1%E6%88%91%E7%A2%B0%E5%88%B0%E7%9A%84%E5%9C%A8springboot/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="LLCH Liu">
      <meta itemprop="description" content="Here we go!!!!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Here We Go">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/09/12/%E5%85%AB%E8%82%A1%E6%88%91%E7%A2%B0%E5%88%B0%E7%9A%84%E5%9C%A8springboot/" class="post-title-link" itemprop="url">八股我碰到的在springboot</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-09-12 21:56:15" itemprop="dateCreated datePublished" datetime="2023-09-12T21:56:15+08:00">2023-09-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-09-13 19:52:19" itemprop="dateModified" datetime="2023-09-13T19:52:19+08:00">2023-09-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%85%AB%E8%82%A1/" itemprop="url" rel="index"><span itemprop="name">-八股</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="websocket（来源heima）"><a href="#websocket（来源heima）" class="headerlink" title="websocket（来源heima）"></a>websocket（来源heima）</h3><p>WebSocket 是基于 TCP 的一种新的<strong>网络协议</strong>。它实现了浏览器与服务器全双工通信——浏览器和服务器只需要完成一次握手，两者之间就可以创建<strong>持久性</strong>的连接， 并进行<strong>双向</strong>数据传输。</p>
<p>实现览器与服务器全双工通信。浏览器既可以向服务器发送消息，服务器也可主动向浏览器推送消息。</p>
<p><strong>HTTP协议和WebSocket协议对比：</strong></p>
<ul>
<li>HTTP是<strong>短连接</strong></li>
<li>WebSocket是<strong>长连接</strong></li>
<li>HTTP通信是<strong>单向</strong>的，基于请求响应模式</li>
<li>WebSocket支持<strong>双向</strong>通信</li>
<li>HTTP和WebSocket底层都是TCP连接</li>
</ul>
<p><strong>WebSocket缺点：</strong></p>
<p>服务器长期维护长连接需要一定的成本<br>各个浏览器支持程度不一<br>WebSocket 是长连接，受网络限制比较大，需要处理好重连</p>
<p><strong>WebSocket应用场景：</strong></p>
<p>1). 视频弹幕</p>
<p>2). 网页聊天</p>
<p>3). 体育实</p>
<p>4). 股票基金报价实时更新况更新</p>
<p><strong>实现步骤：</strong></p>
<p>1). 直接使用websocket.html页面作为WebSocket客户端</p>
<p>2). 导入WebSocket的maven坐标</p>
<p>3). 导入WebSocket服务端组件WebSocketServer，用于和客户端通信</p>
<p>4). 导入配置类WebSocketConfiguration，注册WebSocket的服务端组件</p>
<p>5). 导入定时任务类WebSocketTask，定时向客户端推送数据</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/09/07/Hello-world/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="LLCH Liu">
      <meta itemprop="description" content="Here we go!!!!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Here We Go">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/09/07/Hello-world/" class="post-title-link" itemprop="url">底斯堡演讲</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-09-07 17:45:52 / 修改时间：18:11:11" itemprop="dateCreated datePublished" datetime="2023-09-07T17:45:52+08:00">2023-09-07</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%8B%B1%E6%96%87%E6%BC%94%E8%AE%B2/" itemprop="url" rel="index"><span itemprop="name">-英文演讲</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Four score and seven years ago our fathers brought forth on this continent, a new nation, conceived in Liberty, and dedicated to the proposition that all men are created equal.</p>
<p>Now we are engaged in a great civil war, testing whether that nation, or any nation so conceived and so dedicated, can long endure. We are met on a great battle-field of that war. We have come to dedicate a portion of that field, as a final resting place for those who here gave their lives that that nation might live. It is altogether fitting and proper that we should do this.</p>
<p>But, in a larger sense, we can not dedicate—we can not consecrate—we can not hallow—this ground. The brave men, living and dead, who struggled here, have consecrated it, far above our poor power to add or detract. The world will little note, nor long remember what we say here, but it can never forget what they did here. It is for us the living, rather, to be dedicated here to the unfinished work which they who fought here have thus far so nobly advanced. It is rather for us to be here dedicated to the great task remaining before us—that from these honored dead we take increased devotion to that cause for which they gave the last full measure of devotion—that we here highly resolve that these dead shall not have died in vain—that this nation, under God, shall have a new birth of freedom—and that government of the people, by the people, for the people, shall not perish from the earth.</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/default-index/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/default-index/">1</a><span class="page-number current">2</span>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">LLCH Liu</p>
  <div class="site-description" itemprop="description">Here we go!!!!</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">13</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">LLCH Liu</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

    <span id="busuanzi_container_site_pv">总访问量<span id="busuanzi_value_site_pv"></span>次</span>
    <span class="post-meta-divider">|</span>
    <span id="busuanzi_container_site_uv">总访客数<span id="busuanzi_value_site_uv"></span>人</span>
    <span class="post-meta-divider">|</span>
<!-- 不蒜子计数初始值纠正 -->
<script>
$(document).ready(function() {

    var int = setInterval(fixCount, 50);  // 50ms周期检测函数
    var countOffset = 20000;  // 初始化首次数据

    function fixCount() {            
       if (document.getElementById("busuanzi_container_site_pv").style.display != "none")
        {
            $("#busuanzi_value_site_pv").html(parseInt($("#busuanzi_value_site_pv").html()) + countOffset); 
            clearInterval(int);
        }                  
        if ($("#busuanzi_container_site_pv").css("display") != "none")
        {
            $("#busuanzi_value_site_uv").html(parseInt($("#busuanzi_value_site_uv").html()) + countOffset); // 加上初始数据 
            clearInterval(int); // 停止检测
        }  
    }
       	
});
</script> 








        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  


</body>
</html>
