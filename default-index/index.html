<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"livere","storage":true,"lazyload":false,"nav":null,"activeClass":"livere"},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="Here we go!!!!">
<meta property="og:type" content="website">
<meta property="og:title" content="Here We Go">
<meta property="og:url" content="http://example.com/default-index/index.html">
<meta property="og:site_name" content="Here We Go">
<meta property="og:description" content="Here we go!!!!">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="LLCH Liu">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/default-index/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Here We Go</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Here We Go</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/home/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-resources">

    <a href="/resources/" rel="section"><i class="download fa-fw"></i>resources</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/09/21/synchronized/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="LLCH Liu">
      <meta itemprop="description" content="Here we go!!!!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Here We Go">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/09/21/synchronized/" class="post-title-link" itemprop="url">synchronized</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-09-21 15:52:56 / 修改时间：17:06:01" itemprop="dateCreated datePublished" datetime="2023-09-21T15:52:56+08:00">2023-09-21</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>synchronized关键字解决的是多个线程之间访问资源的同步性，synchronized 翻译为中文的意思是同步，也称之为”同步锁“。</p>
<p>synchronized的作用是保证在同一时刻， 被修饰的代码块或方法只会有一个线程执行，以达到保证并发安全的效果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">Code:</span><br><span class="line">     stack=2, locals=5, args_size=1</span><br><span class="line">        0: bipush        10</span><br><span class="line">        2: istore_1</span><br><span class="line">        3: new           #2                  // class java/lang/Object</span><br><span class="line">        6: dup</span><br><span class="line">        7: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">       10: astore_2</span><br><span class="line">       11: aload_2</span><br><span class="line">       12: dup</span><br><span class="line">       13: astore_3</span><br><span class="line">       14: monitorenter //加锁</span><br><span class="line">       15: getstatic     #3                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">       18: iload_1</span><br><span class="line">       19: invokevirtual #4                  // Method java/io/PrintStream.println:(I)V</span><br><span class="line">      astore_3</span><br><span class="line">       23: monitorexit //解锁</span><br><span class="line">       24: goto          34</span><br><span class="line">       //异常操作</span><br><span class="line">       27: astore        4</span><br><span class="line">       29: aload_3</span><br><span class="line">       30: monitorexit //解锁</span><br><span class="line">       31: aload         4</span><br><span class="line">       33: athrow</span><br><span class="line">       34: return</span><br><span class="line">     Exception table:</span><br><span class="line">        from    to  target type</span><br><span class="line">           15    24    27   any</span><br><span class="line">           27    31    27   any</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p> <code>3: new</code>  放进操作输入栈然后<code>dup</code>，把对象lock复制了一份，为了使用两次。第一次，消耗栈顶引用，用 <code>7: invokespecial</code> 调用构造方法；10: astore_2&#96;是把第二个赋值给2号槽位的lock。这部分是</p>
<p><code>Object lock = new Object()</code>的解读</p>
<p>接下来是syn的方法了，首先<code>11: aload_2</code>将对象加入操作出栈表示syn开始，接下来 <code>dup</code>复制lock引用，一个给<code>monitorenter</code>，一个给<code>monitorexit</code>，分别对应加锁指令和解锁指令。</p>
<p> <code>astore_3</code>先把lock引用存储到3号槽位，栈顶还剩下一个lock引用，此引用配合<code>monitorenter</code>把lock引用消耗，对lock引用指向的对象进行了一个加锁的操作，然后执行打印操作<code>system.out.println</code>15~19。</p>
<p>如果没有异常 <code>astore_3</code>把lcok引用加载到栈顶再执行<code>23: monitorexit</code>对同一个对象执行解锁，然后goto 34结束。</p>
<p>如果出现异常查看异常表<code>Exception table</code>，如果from 15 to 24 出现异常进入27（from27 to 31同理） ，<code>astore</code>存储异常，  <code>astore_3</code>把lcok引用加载到栈顶再执行<code>23: monitorexit</code>对同一个对象执行解锁，<code>aload</code>加载出之前存在4号槽位的异常，<code>athrow</code>抛出，最后结束。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/09/21/G1%E9%87%8D%E7%82%B9%E6%8F%8F%E8%BF%B0%E4%B8%80%E9%81%8D/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="LLCH Liu">
      <meta itemprop="description" content="Here we go!!!!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Here We Go">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/09/21/G1%E9%87%8D%E7%82%B9%E6%8F%8F%E8%BF%B0%E4%B8%80%E9%81%8D/" class="post-title-link" itemprop="url">G1重点描述一遍</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-09-21 10:25:06 / 修改时间：10:29:20" itemprop="dateCreated datePublished" datetime="2023-09-21T10:25:06+08:00">2023-09-21</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>背景</p>
<p>在G1出现之前，包括在cms出现之前</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/09/19/ClassLoading/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="LLCH Liu">
      <meta itemprop="description" content="Here we go!!!!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Here We Go">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/09/19/ClassLoading/" class="post-title-link" itemprop="url">类加载和字节码技术</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-09-19 23:52:06" itemprop="dateCreated datePublished" datetime="2023-09-19T23:52:06+08:00">2023-09-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-09-21 15:52:09" itemprop="dateModified" datetime="2023-09-21T15:52:09+08:00">2023-09-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JVM/" itemprop="url" rel="index"><span itemprop="name">-JVM</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <img src="../filename/11.png" style="zoom:50%;" />



<h1 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a>类加载</h1><p>执行 <code>javac -parameters -d . HellowWorld.java</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HelloWorld 示例</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorld</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译为 <code>HelloWorld.class</code> 得到的<strong>字节码文件</strong>是这个样子的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">0000000 ca fe ba be 00 00 00 34 00 23 0a 00 06 00 15 09 </span><br><span class="line">0000020 00 16 00 17 08 00 18 0a 00 19 00 1a 07 00 1b 07 </span><br><span class="line">0000040 00 1c 01 00 06 3c 69 6e 69 74 3e 01 00 03 28 29 </span><br><span class="line">0000060 56 01 00 04 43 6f 64 65 01 00 0f 4c 69 6e 65 4e </span><br><span class="line">0000100 75 6d 62 65 72 54 61 62 6c 65 01 00 12 4c 6f 63 </span><br><span class="line">0000120 61 6c 56 61 72 69 61 62 6c 65 54 61 62 6c 65 01 </span><br><span class="line">0000140 00 04 74 68 69 73 01 00 1d 4c 63 6e 2f 69 74 63 </span><br><span class="line">0000160 61 73 74 2f 6a 76 6d 2f 74 35 2f 48 65 6c 6c 6f </span><br><span class="line">0000200 57 6f 72 6c 64 3b 01 00 04 6d 61 69 6e 01 00 16 </span><br><span class="line">0000220 28 5b 4c 6a 61 76 61 2f 6c 61 6e 67 2f 53 74 72 </span><br><span class="line">0000240 69 6e 67 3b 29 56 01 00 04 61 72 67 73 01 00 13 </span><br><span class="line">0000260 5b 4c 6a 61 76 61 2f 6c 61 6e 67 2f 53 74 72 69 </span><br><span class="line">0000300 6e 67 3b 01 00 10 4d 65 74 68 6f 64 50 61 72 61 </span><br><span class="line">0000320 6d 65 74 65 72 73 01 00 0a 53 6f 75 72 63 65 46 </span><br><span class="line">0000340 69 6c 65 01 00 0f 48 65 6c 6c 6f 57 6f 72 6c 64</span><br><span class="line">0000360 2e 6a 61 76 61 0c 00 07 00 08 07 00 1d 0c 00 1e </span><br><span class="line">0000400 00 1f 01 00 0b 68 65 6c 6c 6f 20 77 6f 72 6c 64 </span><br><span class="line">0000420 07 00 20 0c 00 21 00 22 01 00 1b 63 6e 2f 69 74 </span><br><span class="line">0000440 63 61 73 74 2f 6a 76 6d 2f 74 35 2f 48 65 6c 6c </span><br><span class="line">0000460 6f 57 6f 72 6c 64 01 00 10 6a 61 76 61 2f 6c 61 </span><br><span class="line">0000500 6e 67 2f 4f 62 6a 65 63 74 01 00 10 6a 61 76 61 </span><br><span class="line">0000520 2f 6c 61 6e 67 2f 53 79 73 74 65 6d 01 00 03 6f </span><br><span class="line">0000540 75 74 01 00 15 4c 6a 61 76 61 2f 69 6f 2f 50 72 </span><br><span class="line">0000560 69 6e 74 53 74 72 65 61 6d 3b 01 00 13 6a 61 76 </span><br><span class="line">0000600 61 2f 69 6f 2f 50 72 69 6e 74 53 74 72 65 61 6d </span><br><span class="line">0000620 01 00 07 70 72 69 6e 74 6c 6e 01 00 15 28 4c 6a </span><br><span class="line">0000640 61 76 61 2f 6c 61 6e 67 2f 53 74 72 69 6e 67 3b </span><br><span class="line">0000660 29 56 00 21 00 05 00 06 00 00 00 00 00 02 00 01 </span><br><span class="line">0000700 00 07 00 08 00 01 00 09 00 00 00 2f 00 01 00 01 </span><br><span class="line">0000720 00 00 00 05 2a b7 00 01 b1 00 00 00 02 00 0a 00 </span><br><span class="line">0000740 00 00 06 00 01 00 00 00 04 00 0b 00 00 00 0c 00 </span><br><span class="line">0000760 01 00 00 00 05 00 0c 00 0d 00 00 00 09 00 0e 00 </span><br><span class="line">0001000 0f 00 02 00 09 00 00 00 37 00 02 00 01 00 00 00 </span><br><span class="line">0001020 09 b2 00 02 12 03 b6 00 04 b1 00 00 00 02 00 0a </span><br><span class="line">0001040 00 00 00 0a 00 02 00 00 00 06 00 08 00 07 00 0b </span><br><span class="line">0001060 00 00 00 0c 00 01 00 00 00 09 00 10 00 11 00 00 </span><br><span class="line">0001100 00 12 00 00 00 05 01 00 10 00 00 00 01 00 13 00 </span><br><span class="line">0001120 00 00 02 00 14</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>根据 JVM 规范，类文件结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">u4 			   magic</span><br><span class="line">u2             minor_version;    </span><br><span class="line">u2             major_version;    </span><br><span class="line">u2             constant_pool_count;    </span><br><span class="line">cp_info        constant_pool[constant_pool_count-1];    </span><br><span class="line">u2             access_flags;    </span><br><span class="line">u2             this_class;    </span><br><span class="line">u2             super_class;   </span><br><span class="line">u2             interfaces_count;    </span><br><span class="line">u2             interfaces[interfaces_count];   </span><br><span class="line">u2             fields_count;    </span><br><span class="line">field_info     fields[fields_count];   </span><br><span class="line">u2             methods_count;    </span><br><span class="line">method_info    methods[methods_count];    </span><br><span class="line">u2             attributes_count;    </span><br><span class="line">attribute_info attributes[attributes_count];</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>魔数</strong><br>对应字节码文件 0~3 字节，表示它是否是【class】类型的文件</p>
<p>0000000 <strong>ca fe ba be</strong> 00 00 00 34 00 23 0a 00 06 00 15 09</p>
<p><strong>版本</strong><br>对应字节码文件 4~7 字节，表示类的版本 00 34（52） 表示是 Java 8</p>
<p>0000000 ca fe ba be <strong>00 00 00 34</strong> 00 23 0a 00 06 00 15 09</p>
<p><strong>常量池</strong></p>
<p><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5">参考官方文档</a></p>
<hr>
<h1 id="字节码指令"><a href="#字节码指令" class="headerlink" title="字节码指令"></a>字节码指令</h1><h2 id="javap工具"><a href="#javap工具" class="headerlink" title="javap工具"></a>javap工具</h2><p><code>javap -v 类名.class</code>来反编译class文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\30287\IdeaProjects\paiXppLL\src\main&gt;javap -v Main.class</span><br><span class="line">Classfile /C:/Users/30287/IdeaProjects/paiXppLL/src/main/Main.class</span><br><span class="line">  Last modified 2021-10-14; size 419 bytes</span><br><span class="line">  MD5 checksum eda2e7897356a975438fe5899c0b4a6c</span><br><span class="line">  Compiled from &quot;Main.java&quot;</span><br><span class="line">public class main.Main</span><br><span class="line">  minor version: 0</span><br><span class="line">  major version: 52</span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line">   #1 = Methodref          #6.#15         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">   #2 = Fieldref           #16.#17        // java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">   #3 = String             #18            // hello world!</span><br><span class="line">   #4 = Methodref          #19.#20        // java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">   #5 = Class              #21            // main/Main</span><br><span class="line">   #6 = Class              #22            // java/lang/Object</span><br><span class="line">   #7 = Utf8               &lt;init&gt;</span><br><span class="line">   #8 = Utf8               ()V</span><br><span class="line">   #9 = Utf8               Code</span><br><span class="line">  #10 = Utf8               LineNumberTable</span><br><span class="line">  #11 = Utf8               main</span><br><span class="line">  #12 = Utf8               ([Ljava/lang/String;)V</span><br><span class="line">  #13 = Utf8               SourceFile</span><br><span class="line">  #14 = Utf8               Main.java</span><br><span class="line">  #15 = NameAndType        #7:#8          // &quot;&lt;init&gt;&quot;:()V</span><br><span class="line">  #16 = Class              #23            // java/lang/System</span><br><span class="line">  #17 = NameAndType        #24:#25        // out:Ljava/io/PrintStream;</span><br><span class="line">  #18 = Utf8               hello world!</span><br><span class="line">  #19 = Class              #26            // java/io/PrintStream</span><br><span class="line">  #20 = NameAndType        #27:#28        // println:(Ljava/lang/String;)V</span><br><span class="line">  #21 = Utf8               main/Main</span><br><span class="line">  #22 = Utf8               java/lang/Object</span><br><span class="line">  #23 = Utf8               java/lang/System</span><br><span class="line">  #24 = Utf8               out</span><br><span class="line">  #25 = Utf8               Ljava/io/PrintStream;</span><br><span class="line">  #26 = Utf8               java/io/PrintStream</span><br><span class="line">  #27 = Utf8               println</span><br><span class="line">  #28 = Utf8               (Ljava/lang/String;)V</span><br><span class="line">&#123;</span><br><span class="line">  public main.Main();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=1, locals=1, args_size=1</span><br><span class="line">         0: aload_0</span><br><span class="line">         1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">         4: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 13: 0</span><br><span class="line"></span><br><span class="line">  public static void main(java.lang.String[]);</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=2, locals=1, args_size=1</span><br><span class="line">         0: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">         3: ldc           #3                  // String hello world!</span><br><span class="line">         5: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">         8: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 15: 0</span><br><span class="line">        line 16: 8</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>2~4本身自己信息</p>
<p>5：全路径名称</p>
<p> <code>flags: ACC_PUBLIC, ACC_SUPER</code>：类的修饰符，public的类</p>
<p><code>Constant pool</code>：常量池</p>
<p><code>Methodref</code>：成员引用</p>
<p><code>invokespecial</code>：调用方法</p>
<h2 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 演示 字节码指令 和 操作数栈、常量池的关系</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo3_1</span> &#123;   </span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        </span><br><span class="line">		<span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;        </span><br><span class="line">		<span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> Short.MAX_VALUE + <span class="number">1</span>;        </span><br><span class="line">		<span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> a + b;        </span><br><span class="line">		System.out.println(c);   </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# javap -v Demo3_1.class</span><br><span class="line">Classfile /root/Demo3_1.class</span><br><span class="line">Last modified Jul 7, 2019; size 665 bytes</span><br><span class="line">MD5 checksum a2c29a22421e218d4924d31e6990cfc5</span><br><span class="line">Compiled from &quot;Demo3_1.java&quot;</span><br><span class="line">public class cn.itcast.jvm.t3.bytecode.Demo3_1</span><br><span class="line">minor version: 0</span><br><span class="line">major version: 52</span><br><span class="line">flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line">#1 = Methodref #7.#26 // java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">#2 = Class #27 // java/lang/Short</span><br><span class="line">#3 = Integer 32768</span><br><span class="line">#4 = Fieldref #28.#29 //</span><br><span class="line">java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">#5 = Methodref #30.#31 // java/io/PrintStream.println:(I)V</span><br><span class="line">#6 = Class #32 // cn/itcast/jvm/t3/bytecode/Demo3_1</span><br><span class="line">#7 = Class #33 // java/lang/Object</span><br><span class="line">#8 = Utf8 &lt;init&gt;</span><br><span class="line">#9 = Utf8 ()V</span><br><span class="line">#10 = Utf8 Code</span><br><span class="line">#11 = Utf8 LineNumberTable</span><br><span class="line">#12 = Utf8 LocalVariableTable</span><br><span class="line">#13 = Utf8 this</span><br><span class="line">#14 = Utf8 Lcn/itcast/jvm/t3/bytecode/Demo3_1;</span><br><span class="line">#15 = Utf8 main</span><br><span class="line">#16 = Utf8 ([Ljava/lang/String;)V</span><br><span class="line">#17 = Utf8 args</span><br><span class="line">#18 = Utf8 [Ljava/lang/String;</span><br><span class="line">#19 = Utf8 a</span><br><span class="line">#22 = Utf8 c</span><br><span class="line">#23 = Utf8 MethodParameters</span><br><span class="line">#24 = Utf8 SourceFile</span><br><span class="line">#25 = Utf8 Demo3_1.java</span><br><span class="line">#26 = NameAndType #8:#9 // &quot;&lt;init&gt;&quot;:()V</span><br><span class="line">#27 = Utf8 java/lang/Short</span><br><span class="line">#28 = Class #34 // java/lang/System</span><br><span class="line">#29 = NameAndType #35:#36 // out:Ljava/io/PrintStream;</span><br><span class="line">#30 = Class #37 // java/io/PrintStream</span><br><span class="line">#31 = NameAndType #38:#39 // println:(I)V</span><br><span class="line">#32 = Utf8 cn/itcast/jvm/t3/bytecode/Demo3_1</span><br><span class="line">#33 = Utf8 java/lang/Object</span><br><span class="line">#34 = Utf8 java/lang/System</span><br><span class="line">#35 = Utf8 out</span><br><span class="line">#36 = Utf8 Ljava/io/PrintStream;</span><br><span class="line">#37 = Utf8 java/io/PrintStream</span><br><span class="line">#38 = Utf8 println</span><br><span class="line">#39 = Utf8 (I)V</span><br><span class="line">&#123;</span><br><span class="line">public cn.itcast.jvm.t3.bytecode.Demo3_1();</span><br><span class="line">descriptor: ()V</span><br><span class="line">flags: ACC_PUBLIC</span><br><span class="line">Code:</span><br><span class="line">stack=1, locals=1, args_size=1</span><br><span class="line">0: aload_0</span><br><span class="line">1: invokespecial #1 // Method java/lang/Object.&quot;</span><br><span class="line">&lt;init&gt;&quot;:()V</span><br><span class="line">4: return</span><br><span class="line">LineNumberTable:</span><br><span class="line">line 6: 0</span><br><span class="line">LocalVariableTable:</span><br><span class="line">Start Length Slot Name Signature</span><br><span class="line">0 5 0 this Lcn/itcast/jvm/t3/bytecode/Demo3_1;</span><br><span class="line">public static void main(java.lang.String[]);</span><br><span class="line">descriptor: ([Ljava/lang/String;)V</span><br><span class="line">flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">Code:</span><br><span class="line">stack=2, locals=4, args_size=1</span><br><span class="line">0: bipush 10</span><br><span class="line">2: istore_1</span><br><span class="line">3: ldc #3 // int 32768</span><br><span class="line">5: istore_2</span><br><span class="line">6: iload_1</span><br><span class="line">7: iload_2</span><br><span class="line">8: iadd</span><br><span class="line">9: istore_3</span><br><span class="line">10: getstatic #4 // Field</span><br><span class="line">java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">13: iload_3</span><br><span class="line">14: invokevirtual #5 // Method</span><br><span class="line">java/io/PrintStream.println:(I)V</span><br><span class="line">17: return</span><br><span class="line">LineNumberTable:</span><br><span class="line">line 8: 0</span><br><span class="line">line 9: 3</span><br><span class="line">line 12: 17</span><br><span class="line">LocalVariableTable:</span><br><span class="line">Start Length Slot Name Signature</span><br><span class="line">0 18 0 args [Ljava/lang/String;</span><br><span class="line">3 15 1 a I</span><br><span class="line">6 12 2 b I</span><br><span class="line">10 8 3 c I</span><br><span class="line">MethodParameters:</span><br><span class="line">Name Flags</span><br><span class="line">args</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>常量池载入运行时常量池</strong></p>
<img src="../filename/12.png" style="zoom: 67%;" />



<p><strong>字节方法码载入方法区</strong></p>
<img src="../filename/13 .png" style="zoom:67%;" />

<p><strong>main线程开始运行，分配栈帧内存</strong></p>
<p><img src="/../filename/14.png"></p>
<p><strong>执行引擎开始执行字节码</strong></p>
<p><strong>bipush10</strong>：</p>
<ul>
<li>将一个 byte 压入操作数栈（其长度会补齐 4 个字节），类似的指令还有</li>
<li>sipush 将一个 short 压入操作数栈（其长度会补齐 4 个字节）</li>
<li>ldc 将一个 int 压入操作数栈</li>
<li>ldc2_w 将一个 long 压入操作数栈（分两次压入，因为 long 是 8 个字节）</li>
<li>这里小的数字都是和字节码指令存在一起，超过 short 范围的数字存入了常量池</li>
</ul>
<p><strong>istore 1</strong>：</p>
<ul>
<li>将操作数栈栈顶元素弹出，放入局部变量表的slot 1中</li>
</ul>
<img src="../filename/15.png" style="zoom:50%;" />

<p><strong>ldc #3</strong>：</p>
<ul>
<li>从常量池加载 #3 数据到操作数栈</li>
<li>注意 <code>Short.MAX_VALUE</code> 是 32767，所以 32768 &#x3D; Short.MAX_VALUE + 1 实际是在编译期间计算好的</li>
</ul>
<img src="../filename/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATEwuTEVCUk9O,size_20,color_FFFFFF,t_70,g_se,x_16.png" alt="在这里插入图片描述" style="zoom:50%;" />

<p><strong>istore_2</strong>：</p>
<p>将操作数栈中的元素弹出，放到局部变量表的2号位置</p>
<img src="../filename/16.png" style="zoom:50%;" />

<p><strong>iload1</strong>：</p>
<p>将局部变量表中1号位置的元素放入操作数栈中</p>
<p><strong>iload2</strong>：</p>
<p>将局部变量表中2号位置的元素放入操作数栈中</p>
<p><strong>iadd</strong>：</p>
<p>将操作数栈中的两个元素弹出栈并相加，结果在压入操作数栈中</p>
<p><strong>istore 3</strong>：</p>
<p>将操作数栈中的元素弹出，放入局部变量表的3号位置</p>
<p><strong>getstatic #4</strong>：</p>
<p>在运行时常量池中找到#4，发现是一个对象</p>
<p>在堆内存中找到该对象，并将其<strong>引用</strong>放入操作数栈中</p>
<p><strong>iload 3</strong>：</p>
<p><strong>invokevirtual 5</strong>：</p>
<ul>
<li>找到常量池 #5 项</li>
<li>定位到方法区 <code>java/io/PrintStream.println:(I)V</code> 方法</li>
<li>生成新的栈帧（分配 locals、stack等）</li>
<li>传递参数，执行新栈帧中的字节码</li>
<li>执行完毕，弹出栈帧</li>
<li>清除 main 操作数栈内容</li>
</ul>
<p><strong>return</strong>：</p>
<ul>
<li>完成 main 方法调用，弹出 main 栈帧</li>
<li>程序结束</li>
</ul>
<hr>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Main</span> <span class="variable">m</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Main</span>();</span><br><span class="line">        m.test1();</span><br><span class="line">        m.test2();</span><br><span class="line">        m.test3();</span><br><span class="line">        Main.test4();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>不同方法在调用时，对应的虚拟机指令有所区别：</p>
<ul>
<li><p><code>invokeSpecial</code>和<code>invokeStatic</code>属于<strong>静态绑定</strong></p>
</li>
<li><p>私有、构造、被final修饰的方法，在调用时都使用<code>invokespecial</code>指令</p>
</li>
<li><p>普通成员方法在调用时，使用i<code>nvokevirtual</code>指令。因为<strong>编译期间无法确定该方法的内容</strong>，只有在运行期间才能确定，属于<strong>动态绑定</strong>，即支持多态</p>
</li>
<li><p>静态方法在调用时使用**<code>invokestatic</code>**指令</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Code:</span><br><span class="line">     stack=2, locals=2, args_size=1</span><br><span class="line">        0: new           #2                  // class main/Main</span><br><span class="line">        3: dup</span><br><span class="line">        4: invokespecial #3                  // Method &quot;&lt;init&gt;&quot;:()V</span><br><span class="line">        7: astore_1</span><br><span class="line">        8: aload_1</span><br><span class="line">        9: invokespecial #4                  // Method test1:()V</span><br><span class="line">       12: aload_1</span><br><span class="line">       13: invokespecial #5                  // Method test2:()V</span><br><span class="line">       16: aload_1</span><br><span class="line">       17: invokevirtual #6                  // Method test3:()V</span><br><span class="line">       20: invokestatic  #7                  // Method test4:()V</span><br><span class="line">       23: return</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<ul>
<li>new 是创建【对象】，给对象分配堆内存，执行成功会将【对象引用】压入操作数栈</li>
<li>dup 是<strong>复制</strong>操作数栈栈顶的内容，本例即为【对象引用】，为什么需要两份引用呢，一个是要配合 <code>invokespecial</code> 调用该对象的构造方法 （会消耗掉栈顶一个引用），另一个要配合 <code>astore_1</code> 赋值给局部变量</li>
<li>成员方法与静态方法调用的另一个区别是，执行方法前是否需要【对象引用】</li>
</ul>
<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><ul>
<li><p>运行jps，获取进程Id</p>
</li>
<li><p>运行Hsdb工具，可以看到比较底层的原理</p>
</li>
<li><p>进入JDK安装目录，执行**<code>java -cp .lib/sa-jdi.jar sun.jvm.hotspot.HSDB</code>**，进入图形界面</p>
<p>Attach id</p>
</li>
</ul>
<hr>
<p> <strong>vtable</strong>:多态的方法存在在一张加vtable的虚方法表中，静态，final，私有不会在内</p>
<p><strong>从JVM内部角度看，java多态的实现是通过itable（interface method table：接口方法表）, vtable（virtual method table：虚函数表）来实现方法的准确跳转。</strong></p>
<ul>
<li>先通过栈帧中对象的引用找到对象</li>
<li>分析对象头，找到对象实际的Class</li>
<li>Class结构中有<strong>vtable</strong>，它在类加载的链接阶段就已经根据方法的重写规则生成好了</li>
<li>查询<strong>vtable</strong>找到方法的具体地址</li>
<li>执行方法的字节码</li>
</ul>
<hr>
<p>异常catch</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            i = <span class="number">10</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            i = <span class="number">20</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>重点，省略了部分</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Code:</span><br><span class="line">    stack=1, locals=3, args_size=1</span><br><span class="line">       0: iconst_0</span><br><span class="line">       1: istore_1</span><br><span class="line">       2: bipush        10</span><br><span class="line">       4: istore_1</span><br><span class="line">       5: goto          12</span><br><span class="line">       8: astore_2</span><br><span class="line">       9: bipush        20</span><br><span class="line">      11: istore_1</span><br><span class="line">      12: return</span><br><span class="line">    Exception table:</span><br><span class="line">       from    to  target type</span><br><span class="line">           2     5     8   Class java/lang/Exception</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><p>可以看到多出来一个 Exception table 的结构，[from, to) 是前闭后开（也就是检测2~4行）的检测范围，一旦这个范围内的字节码执行出现异常，先进行类型匹配，是否一致，如果一致，进入 target 所指示行号。</p>
</li>
<li><p>8行的字节码指令 astore_2 是将异常对象引用存入局部变量表的2号位置（为e）。 </p>
</li>
<li><p>因为异常出现时，<strong>只能进入</strong> Exception table 中<strong>一个分支</strong>，所以局部变量表 slot 2 位置<strong>被共用</strong>，异常都放在一个槽位，没有必要创建多个槽位的信息。</p>
</li>
</ul>
<ul>
<li><p>finally的原理是将finally{}块中的代码分别放在try{…}的最后和catch{…}的最后</p>
</li>
<li><p>如果try除了问题,直接进入catch中,然后catch后面复制的finally就会被执行</p>
</li>
<li><p>如果没有出问题,try{}后面的代码就会被执行</p>
</li>
<li><p>todo 如果出现catch的异常类不匹配,程序就不会往下走了,此时的finally也不会被执行</p>
</li>
</ul>
<ul>
<li>因为检测的那段代码出现异常的时候肯定是在插入的finally前，所以不管有无异常，都只会执行一次finally块代码</li>
</ul>
<hr>
<ul>
<li>在返回数据时，先把返回结果暂存，等finally中内容执行完了再把暂存结果返回</li>
<li>由于 ﬁnally 中的 ireturn 被插入了所有可能的流程，因此返回结果肯定以ﬁnally的为准<br>如果在 ﬁnally 中出现了 return，会吞掉异常，所以不要在finally中进行返回操作</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/09/19/experience/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="LLCH Liu">
      <meta itemprop="description" content="Here we go!!!!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Here We Go">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/09/19/experience/" class="post-title-link" itemprop="url">调优经验</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-09-19 17:51:55 / 修改时间：23:57:43" itemprop="dateCreated datePublished" datetime="2023-09-19T17:51:55+08:00">2023-09-19</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JVM/" itemprop="url" rel="index"><span itemprop="name">-JVM</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="调优经验"><a href="#调优经验" class="headerlink" title="调优经验"></a>调优经验</h1><h2 id="GC调优"><a href="#GC调优" class="headerlink" title="GC调优"></a>GC调优</h2><h3 id="前置经验"><a href="#前置经验" class="headerlink" title="前置经验"></a>前置经验</h3><h4 id="经常发生GC"><a href="#经常发生GC" class="headerlink" title="经常发生GC"></a><strong>经常发生GC</strong></h4><ul>
<li><p>数据太多</p>
<p>resultSet &#x3D;statement.executeQuery(“select * from 大表 limit in”)</p>
</li>
<li><p>数据表示太臃肿？</p>
<p>只显示用户一部分数据就够。</p>
</li>
<li><p>是否存在内存泄露</p>
<p>长时间存活对象比如（static），尝试软弱引用，第三方缓存实现</p>
</li>
</ul>
<h4 id="新生代调优"><a href="#新生代调优" class="headerlink" title="新生代调优"></a><strong>新生代调优</strong></h4><ul>
<li>TLAB thread-local allocation buffer（可防止多个线程创建对象时的互相干扰混乱）</li>
<li>当新生代发生垃圾回收（新生代都是复制算法），在Eden区域及幸存区<strong>from</strong>对象复制到<strong>to</strong>中。</li>
<li>Oracle建议新生代大于1&#x2F;4并且小于1&#x2F;2 overall heap size。</li>
<li><code>-XX:+PrintTenuringDistribution</code> 可以显示详细信息</li>
</ul>
<h4 id="老年代内存预设"><a href="#老年代内存预设" class="headerlink" title="老年代内存预设"></a>老年代内存预设</h4><p><code>-XX:CMSInitiatingOccupancyFraction=percent</code>（越大越好，twitter工程师建议设置为0。一般设置为75%~80%）</p>
<h3 id="实战案例"><a href="#实战案例" class="headerlink" title="实战案例"></a>实战案例</h3><h4 id="Full-GC和Minor-GC频繁"><a href="#Full-GC和Minor-GC频繁" class="headerlink" title="Full GC和Minor GC频繁"></a>Full GC和Minor GC频繁</h4><p>空间紧张，先从新生代开始看，可能是新生代空间太小的原因，新生代空间宽裕了就不再那么频繁了。</p>
<h4 id="请求高峰期发生Full-GC，单次暂停时间特别长（CMS）"><a href="#请求高峰期发生Full-GC，单次暂停时间特别长（CMS）" class="headerlink" title="请求高峰期发生Full GC，单次暂停时间特别长（CMS）"></a>请求高峰期发生Full GC，单次暂停时间特别长（CMS）</h4><p>查看GC日志，要扫描整个堆内存。发现是重新扫描时间过长，使用<code>-XX:+CMSScavengeBeforceRemark</code>在重新你扫描前进行一次垃圾回收</p>
<hr>
<h3 id="线程诊断"><a href="#线程诊断" class="headerlink" title="线程诊断"></a>线程诊断</h3><h3 id="实战案例-1"><a href="#实战案例-1" class="headerlink" title="实战案例"></a>实战案例</h3><h4 id="cpu占用过多"><a href="#cpu占用过多" class="headerlink" title="cpu占用过多"></a>cpu占用过多</h4><p> top 先定位到CPU 占用高的 Java 进程，再利用 top -Hp 进程id 来定位是哪个线程，最后再用 jstack 排查</p>
<ul>
<li><p>使用top命令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用命令查看进程中的线程              pid：进程id，       tid：线程id</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ps H -eo pid,tid,%cpu</span><br><span class="line"></span><br><span class="line">ps H -eo pid,tid,%cpu | grep 进程id      //只留下感兴趣的进程</span><br></pre></td></tr></table></figure>
</li>
<li><p>将得到的线程id转化为16进制，在thread[x]，找出具体的thread</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstack 线程id</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="迟迟得不到结果"><a href="#迟迟得不到结果" class="headerlink" title="迟迟得不到结果"></a>迟迟得不到结果</h4><p>可能出现了死锁。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/09/19/%E8%B0%83%E4%BC%98%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="LLCH Liu">
      <meta itemprop="description" content="Here we go!!!!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Here We Go">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/09/19/%E8%B0%83%E4%BC%98%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/" class="post-title-link" itemprop="url">调优常用命令</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-09-19 17:50:14 / 修改时间：23:27:04" itemprop="dateCreated datePublished" datetime="2023-09-19T17:50:14+08:00">2023-09-19</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="查看虚拟机运行参数"><a href="#查看虚拟机运行参数" class="headerlink" title="查看虚拟机运行参数"></a>查看虚拟机运行参数</h4><p><code>java -XX:+PrintFlagsFinal -version | grep GC</code></p>
<h4 id="显示新老年代详细信息"><a href="#显示新老年代详细信息" class="headerlink" title="显示新老年代详细信息"></a>显示新老年代详细信息</h4><p><code>-XX:+PrintTenuringDistribution</code></p>
<h4 id="老年代内存预设"><a href="#老年代内存预设" class="headerlink" title="老年代内存预设"></a>老年代内存预设</h4><p><code>-XX:CMSInitiatingOccupancyFraction=percent</code>（越大越好，twitter工程师建议设置为0。一般设置为75%~80%）</p>
<h4 id="堆内存溢出诊断"><a href="#堆内存溢出诊断" class="headerlink" title="堆内存溢出诊断"></a>堆内存溢出诊断</h4><p>可以通过<strong>反编译</strong><code>javac xxx.java</code>来查看类的信息</p>
<ul>
<li><p>jps工具</p>
<p>查看当前系统哪些java进程</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jps</span><br></pre></td></tr></table></figure>


</li>
<li><p>jmap工具</p>
<p>查看堆内存占用情况，只能查看某一时刻的状态</p>
<p>Heap Configuration:堆的设置</p>
<p>Heap Usage &#x2F; Eden Space &#x2F;used：查看占用内存</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmap -heap 进程id</span><br></pre></td></tr></table></figure>
</li>
<li><p>jconsole工具</p>
<p>图形界面工具，可以连续监测</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jconsole</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h4><h5 id="垃圾回收后内存过高"><a href="#垃圾回收后内存过高" class="headerlink" title="垃圾回收后内存过高"></a>垃圾回收后内存过高</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jvisualvm</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="吞吐量优先-Parallel-Scavenge收集器"><a href="#吞吐量优先-Parallel-Scavenge收集器" class="headerlink" title="吞吐量优先(Parallel Scavenge收集器)"></a>吞吐量优先(Parallel Scavenge收集器)</h4><p>多线程，堆内存较大，多核CPU。单位时间内，STW的时间最短。总时间最短。</p>
<p><strong>开启垃圾回收器</strong>：vm参数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseParallelGC~-XX:+UseParalleOldGC</span><br></pre></td></tr></table></figure>

<p>1.8都默认开启前者代表是新生代的垃圾回收器，使用的是复制算法；后者工作在老年代，采用标记整理算法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:ParallelGCThreads=n</span><br></pre></td></tr></table></figure>

<p>控制ParallelGC运行时的线程数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseAdaptiveSizePolicy</span><br></pre></td></tr></table></figure>

<p>新生代自适应大小调整策略</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:GCTimeRatio=ratio</span><br></pre></td></tr></table></figure>

<p>调节垃圾回收时间和总时间的占比。1&#x2F;(ratio+1)，垃圾回收总时间占比</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:MaxGCPauseMillis=ms</span><br></pre></td></tr></table></figure>

<p>每次垃圾回收最大暂停毫秒数</p>
<h4 id="响应时间优先（CMS"><a href="#响应时间优先（CMS" class="headerlink" title="响应时间优先（CMS)"></a>响应时间优先（CMS)</h4><p>多线程，-堆内存较大，多核CPU。尽可能让单次STW时间最短。适用于关注响应速度的服务</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseConcMarkSweepGC-XX:+UseParNewGC~SerialOld</span><br></pre></td></tr></table></figure>

<p>基于标记清除算法的垃圾回收器。该算法导致过度内存碎片,分配对象时MinorGC不足，老年代也不足，导致并发失败，CMSGC退化为SerialOld，单线程串行的垃圾回收。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:ParallelGCThreads=n~-XX:ConGCThreads=threads</span><br></pre></td></tr></table></figure>

<p>前者：并行的垃圾回收线程数，一般跟cpu核数一样。</p>
<p>后者：并发的垃圾回收线程数，一般设为并行线程数的四分之一。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:CMSInitiatingOccupancyFraction=percent</span><br></pre></td></tr></table></figure>

<p>作用：并发清理的时候会产生新的垃圾，不能等到内存不足了才去清理。要预留空间给浮动垃圾。值设置的越小，触发时机越早。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+CMSScavengeBeforceRemark</span><br></pre></td></tr></table></figure>

<p>作用：在重新标记前对新生代的进行垃圾回收，新生代存活对象少，减轻重新标记压力。（+打开，-关闭）</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/09/14/JVM/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="LLCH Liu">
      <meta itemprop="description" content="Here we go!!!!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Here We Go">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/09/14/JVM/" class="post-title-link" itemprop="url">JVM-内存结构及垃圾回收</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-09-14 20:35:51" itemprop="dateCreated datePublished" datetime="2023-09-14T20:35:51+08:00">2023-09-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-09-21 12:12:14" itemprop="dateModified" datetime="2023-09-21T12:12:14+08:00">2023-09-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JVM/" itemprop="url" rel="index"><span itemprop="name">-JVM</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="什么是JVM"><a href="#什么是JVM" class="headerlink" title="什么是JVM?"></a>什么是JVM?</h2><p><strong>Java Virtual Machine</strong> - java程序的运行环境（Java 二进制字节码的运行环境）</p>
<p>屏蔽Java代码与底层操作系统的差异</p>
<ul>
<li>对外提供一致的运行环境（平台无关性）</li>
<li>自动内存管理，垃圾回收功能</li>
<li>数组下标越界检查（抛异常比新元素覆盖程序其他部分强）</li>
<li>多态</li>
</ul>
<p><strong>JRE</strong> :        JVM+基础类库（日期类等等IO类）</p>
<p>**JDK ** :      JVM+编译工具（javac,  Javap，内存检测工具等等）</p>
<p><strong>开发JavaSE程序</strong>：   JDK + IDE工具</p>
<p><strong>开发JavaEE程序</strong>：   JDK+IDE工具+应用服务器（tomcat)</p>
<h2 id="JVM组成"><a href="#JVM组成" class="headerlink" title="JVM组成:"></a>JVM组成:</h2><p><img src="/filename/1.png" alt="https://github.com/LiuLCH1014/LiuLCH1014.github.io/blob/main/filename/1.png"></p>
<p>java源代码编译为二进制字节码以后(Java class),经过类加载器(classLoader),才能加载到JVM内存结构中被运行。</p>
<p>类都是放在方法区，类创建的实例对象放在堆，实例对象调用方法时用到虚拟机栈等</p>
<p>方法执行时由执行引擎中的解释器逐行解释，即时编译器优化执行频繁调用的代码。</p>
<p>GC会对堆中不再引用的对象垃圾回收。</p>
<p>Java代码中不方便实现的功能，本地接口调用本地操作系统提供的功能方法</p>
<hr>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><h4 id="垃圾回收是否涉及栈内存？"><a href="#垃圾回收是否涉及栈内存？" class="headerlink" title="垃圾回收是否涉及栈内存？"></a>垃圾回收是否涉及栈内存？</h4><p>栈自动出栈，不需要垃圾回收管理栈内存</p>
<h4 id="栈内存分配越大越好吗"><a href="#栈内存分配越大越好吗" class="headerlink" title="栈内存分配越大越好吗"></a>栈内存分配越大越好吗</h4><p>栈越大，线程数越少</p>
<h4 id="方法内的局部变量是否线程安全"><a href="#方法内的局部变量是否线程安全" class="headerlink" title="方法内的局部变量是否线程安全-"></a>方法内的局部变量是否线程安全-</h4><p>这要看这个变量是对每个线程共享的，还是每个线程私有的。共享的不用考虑线程安全。</p>
<p>如果是static，<strong>静态变量属于类</strong>，放在方法区，属于线程共享的数据。</p>
<p>StringBuilder本来就不是线程安全的，如果用StringBuffer就是线程安全的。</p>
<p>是不是线程安全不仅要看是否是方法内的局部变量，也要看是否逃离方法的作用范围。</p>
<h4 id="栈—内存溢出"><a href="#栈—内存溢出" class="headerlink" title="栈—内存溢出"></a>栈—内存溢出</h4><ul>
<li>线程请求的栈深度大于虚拟机所允许的最大深度，抛出StackOverflowError</li>
<li>虚拟机的栈内存如果允许动态扩展，当栈容量无法申请到足够的内存抛出 OutOfMemoryError</li>
</ul>
<hr>
<h2 id="JVM内存结构"><a href="#JVM内存结构" class="headerlink" title="JVM内存结构"></a>JVM内存结构</h2><h3 id="程序计数器——Program-Counter-Register"><a href="#程序计数器——Program-Counter-Register" class="headerlink" title="程序计数器——Program Counter Register"></a>程序计数器——Program Counter Register</h3><p>记住下一条<strong>jvm指令</strong>的执行地址（寄存器）</p>
<ul>
<li><strong>线程私有</strong>  每个线程都有自己的register</li>
<li>不会存在内存溢出</li>
</ul>
<hr>
<h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>线程运行需要的内存空间</p>
<p>不指定大小Linux，Oracle，macSO都是<strong>1024k</strong></p>
<p>windows会根据虚拟内存影响栈的大小</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-Xss size</span><br><span class="line"></span><br><span class="line">//example</span><br><span class="line">-Xss 1m</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="栈帧"><a href="#栈帧" class="headerlink" title="栈帧"></a>栈帧</h4><p><em><strong>每个方法需要的内存</strong></em>（参数，局部变量，返回地址）</p>
<hr>
<h4 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h4><p>用c和c++编写的本地方法，来真正与操作系统和本地API打交道，可以间接使用本地方法，这些本地方法使用的栈就是本地方法栈。</p>
<p>native方法有C&#x2F;C++底层实现。</p>
<p>当调用本地方法时程序计数器为空。</p>
<hr>
<h3 id="Heap-堆"><a href="#Heap-堆" class="headerlink" title="Heap 堆"></a>Heap 堆</h3><p>   通过<strong>new</strong>关键字，创建对象都会使用堆内存</p>
<ul>
<li>它是线程共享的，堆中对象都需要考虑线程安全问题</li>
<li>有垃圾回收机制</li>
</ul>
<hr>
<h4 id="堆内存溢出诊断"><a href="#堆内存溢出诊断" class="headerlink" title="堆内存溢出诊断"></a>堆内存溢出诊断</h4><p>可以通过<strong>反编译</strong><code>javac xxx.java</code>来查看类的信息</p>
<ul>
<li><p>jps工具</p>
<p>查看当前系统哪些java进程</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jps</span><br></pre></td></tr></table></figure>


</li>
<li><p>jmap工具</p>
<p>查看堆内存占用情况，只能查看某一时刻的状态</p>
<p>Heap Configuration:堆的设置</p>
<p>Heap Usage &#x2F; Eden Space &#x2F;used：查看占用内存</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmap -heap 进程id</span><br></pre></td></tr></table></figure>
</li>
<li><p>jconsole工具</p>
<p>图形界面工具，可以连续监测</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jconsole</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h4><h5 id="垃圾回收后内存过高"><a href="#垃圾回收后内存过高" class="headerlink" title="垃圾回收后内存过高"></a>垃圾回收后内存过高</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jvisualvm</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="方法区-Method-Area"><a href="#方法区-Method-Area" class="headerlink" title="方法区-Method Area"></a>方法区-Method Area</h3><p>会受到内存限制，抛出<strong>OutOfMemoryError</strong>异常</p>
<p><img src="/filename/2.png" alt="https://github.com/LiuLCH1014/LiuLCH1014.github.io/blob/main/filename/2.png"></p>
<p>方法区是所有java虚拟机线程的<strong>共享</strong>的区，用于存储已被虚拟机加载的类型信息，常量，静态变量，即时编译器编译后的代码缓存等数据</p>
<p>JDK1.8版本之前方法区用的堆的内存，叫<strong>永久代</strong>，JDK1.8之后用的操作系统的内存，叫<strong>元空间</strong>。</p>
<p>元空间被在本地内存中</p>
<p>永久代是方法区的实现，方法区也是一种规范，具体的实现是永久代和元空间，不同的厂商实现方式不同</p>
<h3 id="运行时常量池-Runtime-Constant-Pool"><a href="#运行时常量池-Runtime-Constant-Pool" class="headerlink" title="运行时常量池-Runtime Constant Pool"></a>运行时常量池-Runtime Constant Pool</h3><p>常量池表（存放编译时期生成的字面量和符号引用）在类加载后存放到方法区的运行时常量池中。</p>
<p>动态性   Java语言并不要求常量编译时产生，运行期间也可以将新的常量放入池中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string1.intern();</span><br></pre></td></tr></table></figure>

<p>intern方法，主动将<strong>串池中还没有的字符串对象</strong>放入串池，</p>
<p>将字符串对象s1尝试放入串池，<strong>如果原来存在有并不会放入</strong>，<strong>还会在堆中</strong>，如果没有则放入串池，会把串池的对象返回。</p>
<h3 id="StringTable"><a href="#StringTable" class="headerlink" title="StringTable"></a>StringTable</h3><p>stringtable是串池，<strong>串池是常量池中的一部分</strong>。</p>
<p>垃圾回收不会发生在永久代(PermGen space)，如果永久代满了或者是超过了临界值，会触发完全垃圾回收(Full GC)。</p>
<h4 id="stringTable性能调优"><a href="#stringTable性能调优" class="headerlink" title="stringTable性能调优"></a>stringTable性能调优</h4><ul>
<li><p>主要调整hashTable桶的个数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:SringTableSize=×××</span><br></pre></td></tr></table></figure>
</li>
<li><p>考虑字符串对象是否入池</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//example</span></span><br><span class="line">intern();</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itcast.itheima.xpp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        String s1=<span class="string">&quot;a&quot;</span>;</span><br><span class="line">        String s2=<span class="string">&quot;b&quot;</span>;</span><br><span class="line">        String s3=<span class="string">&quot;a&quot;</span>+<span class="string">&quot;b&quot;</span>;</span><br><span class="line">        String s4=s1+s2;</span><br><span class="line">        String s5=<span class="string">&quot;ab&quot;</span>;</span><br><span class="line">        String s6=s4.intern();</span><br><span class="line">        System.out.println(s3==s4);<span class="comment">//false</span></span><br><span class="line">        System.out.println(s3==s5);<span class="comment">//true</span></span><br><span class="line">        System.out.println(s3==s6);<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">        String x2=<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;c&quot;</span>)+<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;d&quot;</span>);</span><br><span class="line">        String x1=<span class="string">&quot;cd&quot;</span>;</span><br><span class="line">        x2.intern();</span><br><span class="line">        System.out.println(x1==x2);<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        String x4=<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;e&quot;</span>)+<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;f&quot;</span>);</span><br><span class="line">        x4.intern();</span><br><span class="line">        String x3=<span class="string">&quot;ef&quot;</span>;</span><br><span class="line">        System.out.println(x3==x4);<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h3><p>这部分被频繁引用，也会导致<strong>OutOfMemoryError</strong></p>
<p>一般配置虚拟机参数，会根据实际内存去设置-Xmx等参数信息，但经常忽略直接内存，从而导致动态扩展出现OutOfMemoeryError。</p>
<p>NIO类引入了一种基于通道与缓存区的I&#x2F;O方式，可以使用Native函数库直接分配<strong>堆外内存</strong>，通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。<strong>避免了在Java堆和Native堆中来回复制</strong>。</p>
<p><img src="/filename/3.png" alt="https://github.com/LiuLCH1014/LiuLCH1014.github.io/blob/main/filename/3.png"></p>
<p>通过两次缓冲区，效率不高</p>
<hr>
<h4 id="直接内存回收原理"><a href="#直接内存回收原理" class="headerlink" title="直接内存回收原理"></a>直接内存回收原理</h4><ul>
<li>使用了 Unsafe 类来完成直接内存的分配回收，回收需要主动调用<code>freeMemory</code> 方法</li>
<li>ByteBuffer 的实现内部使用了 Cleaner（虚引用）来检测 ByteBuffer 。一旦ByteBuffer 被垃圾回收，那么会由 ReferenceHandler（守护线程） 来调用 <code>Cleaner.clean</code> 方法调用 <strong>freeMemory</strong> 来释放内存</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Code_06_DirectMemoryTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">_1GB</span> <span class="operator">=</span> <span class="number">1024</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, NoSuchFieldException, IllegalAccessException &#123;</span><br><span class="line"><span class="comment">//        method();</span></span><br><span class="line">        method1();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 演示 直接内存 是被 unsafe 创建与回收</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span> <span class="keyword">throws</span> IOException, NoSuchFieldException, IllegalAccessException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> Unsafe.class.getDeclaredField(<span class="string">&quot;theUnsafe&quot;</span>);</span><br><span class="line">        field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">Unsafe</span> <span class="variable">unsafe</span> <span class="operator">=</span> (Unsafe)field.get(Unsafe.class);</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">base</span> <span class="operator">=</span> unsafe.allocateMemory(_1GB);</span><br><span class="line">        unsafe.setMemory(base,_1GB, (<span class="type">byte</span>)<span class="number">0</span>);</span><br><span class="line">        System.in.read();</span><br><span class="line"></span><br><span class="line">        unsafe.freeMemory(base);</span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 演示 直接内存被 释放</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">byteBuffer</span> <span class="operator">=</span> ByteBuffer.allocateDirect(_1GB);</span><br><span class="line">        System.out.println(<span class="string">&quot;分配完毕&quot;</span>);</span><br><span class="line">        System.in.read();</span><br><span class="line">        System.out.println(<span class="string">&quot;开始释放&quot;</span>);</span><br><span class="line">        byteBuffer = <span class="literal">null</span>;</span><br><span class="line">        System.gc(); <span class="comment">// 手动 gc</span></span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>直接内存的回收不是通过 JVM 的垃圾回收来释放的，而是通过<code>unsafe.freeMemory</code> 来手动释放。</strong><br>第一步：allocateDirect 的实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ByteBuffer <span class="title function_">allocateDirect</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DirectByteBuffer</span>(capacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>底层是创建了一个 DirectByteBuffer 对象。<br>第二步：DirectByteBuffer 类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">DirectByteBuffer(<span class="type">int</span> cap) &#123;   <span class="comment">// package-private</span></span><br><span class="line">   </span><br><span class="line">    <span class="built_in">super</span>(-<span class="number">1</span>, <span class="number">0</span>, cap, cap);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">pa</span> <span class="operator">=</span> VM.isDirectMemoryPageAligned();</span><br><span class="line">    <span class="type">int</span> <span class="variable">ps</span> <span class="operator">=</span> Bits.pageSize();</span><br><span class="line">    <span class="type">long</span> <span class="variable">size</span> <span class="operator">=</span> Math.max(<span class="number">1L</span>, (<span class="type">long</span>)cap + (pa ? ps : <span class="number">0</span>));</span><br><span class="line">    Bits.reserveMemory(size, cap);</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="variable">base</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        base = unsafe.allocateMemory(size); <span class="comment">// 申请内存</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (OutOfMemoryError x) &#123;</span><br><span class="line">        Bits.unreserveMemory(size, cap);</span><br><span class="line">        <span class="keyword">throw</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    unsafe.setMemory(base, size, (<span class="type">byte</span>) <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (pa &amp;&amp; (base % ps != <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="comment">// Round up to page boundary</span></span><br><span class="line">        address = base + ps - (base &amp; (ps - <span class="number">1</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        address = base;</span><br><span class="line">    &#125;</span><br><span class="line">    cleaner = Cleaner.create(<span class="built_in">this</span>, <span class="keyword">new</span> <span class="title class_">Deallocator</span>(base, size, cap)); <span class="comment">// 通过虚引用，来实现直接内存的释放，this为虚引用的实际对象, 第二个参数是一个回调，实现了 runnable 接口，run 方法中通过 unsafe 释放内存。</span></span><br><span class="line">    att = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里调用了一个 <code>Cleaner .create</code> 方法，且后台线程还会对虚引用的对象监测，<em>如果虚引用的实际对象（这里是 DirectByteBuffer ）被回收以后，就会调用 Cleaner 的 clean 方法，来清除直接内存中占用的内存。</em></p>
<p>jvm调优常用参数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+DisableExplicitGC  // 静止显示的 GC</span><br></pre></td></tr></table></figure>

<p>意思就是禁止我们手动的 GC，比如手动 System.gc() 无效，它是一种 full gc，会回收新生代、老年代，会造成程序执行的时间比较长。所以我们就通过 unsafe 对象调用 freeMemory 的方式释放内存。</p>
<hr>
<h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><p><strong>程序计数器、虚拟机栈、本地方法栈</strong>三个区域随线程生灭。这几个区域的内存分配和回收都具备确定性，方法结束、线程结束，自然回收。</p>
<p>Java堆和方法区就有不确定性。只有在运行期间才知道创建哪些对象，分配和回收具有动态性。</p>
<hr>
<h3 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h3><blockquote>
<p><em>本博客不特别记录引用计数法</em></p>
</blockquote>
<p>可作为GC Root的对象</p>
<ul>
<li><p>虚拟机栈（<strong>栈帧中的本地变量表</strong>）中引用的对象，当前正在运行的方法所用到的参数、局部变量、临时变量。</p>
</li>
<li><p>方法区中类<strong>静态</strong>属性引用的对象，如Java类的<strong>引用类型静态变量</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private static User user1；</span><br></pre></td></tr></table></figure>
</li>
<li><p>方法区中<strong>常量</strong>引用的对象，比如字符串常量池（StringTable）里的引用，<strong>final</strong> 修饰。</p>
</li>
<li><p>本地方法栈中 JNI（即一般说的<strong>Native方法</strong>）引用的对象。</p>
</li>
<li><p>Java 虚拟机内部的引用，如基本数据类型对应的 Class 对象，一些常驻的异常对象(比如 NullPointExcepiton、Out Of MemoryError)等，还有系统类加载器。</p>
</li>
<li><p>所有被同步锁(synchronized 关键字)持有的对象。</p>
</li>
<li><p>反映 Java 虚拟机内部情况的 JMXBean、JVMTI 中注册的回调、本地代码缓存等</p>
</li>
</ul>
<hr>
<h3 id="四种引用"><a href="#四种引用" class="headerlink" title="四种引用"></a>四种引用</h3><ul>
<li><p>强引用是最传统的“引用”的定义，是指在程序代码之中<strong>普遍存在</strong>的引用赋值。无论任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object obj=<span class="keyword">new</span> <span class="title class_">Object</span>()</span><br></pre></td></tr></table></figure>
</li>
<li><p>软引用是用来描述一些还有用，但非必须的对象。只被软引用关联着的对象，<u>在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存，才会抛出内存溢出异常。</u>在 JDK 1.2 版之后提供了 <code>SoftReference</code> 类来实现软引用。</p>
</li>
<li><p>弱引用也是用来描述那些非必须对象，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生为止。当垃圾收集器开始工作，<u>无论当前内存是否足够，都会回收掉只被弱引用关联的对象。</u>在 JDK 1.2 版之后提供了 <code>WeakReference</code> 类来实现弱引用。</p>
</li>
<li><p>虚引用也称为“幽灵引用”或者“幻影引用”，它是最弱的一种引用关系。必须配合<strong>引用队列</strong>使用，主要配合 <strong><code>ByteBuffer</code></strong> 使用，被<strong>引用对象回收时</strong>，会将<strong>虚引用</strong>入队， 由 <strong>Reference Handler</strong> 线程调用虚引用相关方法(<code>Unsafe.freeMemory</code>)释放<strong>直接内存</strong>。。在 JDK 1.2 版之后提供了 PhantomReference 类来实现虚引用。</p>
</li>
</ul>
<blockquote>
<p><em>本博客不特别记录finallize()</em></p>
</blockquote>
<hr>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 演示 软引用</span></span><br><span class="line"><span class="comment"> * -Xmx20m -XX:+PrintGCDetails -verbose:gc</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Code_08_SoftReferenceTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">_4MB</span> <span class="operator">=</span> <span class="number">4</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        method2();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置 -Xmx20m , 演示堆内存不足,</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        ArrayList&lt;<span class="type">byte</span>[]&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> <span class="title class_">byte</span>[_4MB]);</span><br><span class="line">        &#125;</span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 演示 软引用</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        ArrayList&lt;SoftReference&lt;<span class="type">byte</span>[]&gt;&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            SoftReference&lt;<span class="type">byte</span>[]&gt; ref = <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">byte</span>[_4MB]);</span><br><span class="line">            System.out.println(ref.get());</span><br><span class="line">            list.add(ref);</span><br><span class="line">            System.out.println(list.size());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;循环结束：&quot;</span> + list.size());</span><br><span class="line">        <span class="keyword">for</span>(SoftReference&lt;<span class="type">byte</span>[]&gt; ref : list) &#123;</span><br><span class="line">            System.out.println(ref.get());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><p>method1 方法解析：<br>首先会设置一个堆内存的大小为 20m，然后运行 mehtod1 方法，会抛异常，堆内存不足，因为 mehtod1 中的 list 都是强引用。</p>
</li>
<li><p>method2 方法解析：<br>在 list 集合中存放了 软引用对象，当内存不足时，会触发 full gc，将软引用的对象回收。</p>
</li>
<li><p>method3方法解析：</p>
<p>当软引用引用的对象被回收了，但是软引用还存在，所以，一般软引用需要搭配一个引用队列一起使用。</p>
</li>
</ul>
<p><strong>关联了引用队列，当软引用所关联的 byte[] 被回收时，软引用自己会加入到 queue 中去</strong></p>
<hr>
<h3 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h3><p>商用虚拟机里，设计者一般至少会把Java堆划为新生代和老年代两区域。</p>
<p>新生代中，每次垃圾收集大批死去，回收少量对象，逐步晋升到老年代存放。</p>
<p>以上是对HotSpot虚拟机。在IBM J9虚拟机中称为婴儿区，长生区。</p>
<h4 id="标记清除算法"><a href="#标记清除算法" class="headerlink" title="标记清除算法"></a><strong>标记清除算法</strong></h4><p>首先标记出所有需要回收的对象，标记完成后统一回收所有被标记的对象。</p>
<p>把对象的起始结束地址放在空闲列表中，分配新对象时去找。</p>
<p>缺点：执行效率不稳定，大量的标记和清除动作。<strong>内存空间碎片化</strong>问题，标记清除后大量不连续的内存碎片。</p>
<h4 id="标记整理算法"><a href="#标记整理算法" class="headerlink" title="标记整理算法"></a>标记整理算法</h4><p>所有存活对象都向内存空间一端移动，然后清理边界以外的内存。</p>
<p>然而必须全程暂停用户应用程序。</p>
<h4 id="标记复制算法"><a href="#标记复制算法" class="headerlink" title="标记复制算法"></a>标记复制算法</h4><p>将内存容量划为相等两部分，当这一块内存用完，就将还活着的对象复制到另一块上面。</p>
<p>运行简单，高效。但空间浪费大。</p>
<p>存活率较高时就要进行多次复制操作，效率低。如果不想浪费50%空间，就要有额外的空间担保，以应对内存中所有对象100%存活的情况。</p>
<hr>
<h3 id="分代垃圾回收"><a href="#分代垃圾回收" class="headerlink" title="分代垃圾回收"></a>分代垃圾回收</h3><p><img src="/filename/6.png"></p>
<ul>
<li>新生代空间不足时，触发 <strong>Minor GC</strong>，伊甸园和 from 存活的对象使用 copy 复制到 to 中，存活的对象年龄加 1并且<strong>交换 from 和to</strong>。</li>
<li>再次创建对象，若新生代的伊甸园(eden space)又满了，则会再次触发 Minor GC（<strong>minor gc 会引发 stop the world</strong>，暂停其它用户的线程，等垃圾回收结束，用户线程才恢复运行），这时不仅会回收伊甸园中的垃圾，还会回收幸存区中的垃圾，再将活跃对象复制到幸存区TO中。回收以后会<strong>交换两个幸存区</strong>，并让幸存区中的对象寿命加1。</li>
<li>当对象寿命超过阈值时，会晋升至老年代，最大寿命是<strong>15</strong>（寿命是保存在每个对象的对象头中，存寿命的部分是4bit）。</li>
<li>当老年代空间不足，会先尝试触发<strong>Minor GC</strong>，如果之后空间仍不足，那么触发 <strong>Full GC</strong>，因为老年代存活率一般比较高，stop the world的时间更长。</li>
<li>都不够就会触发OutOfMermory</li>
</ul>
<hr>
<h2 id="GC分析"><a href="#GC分析" class="headerlink" title="GC分析"></a>GC分析</h2><h3 id="相关vm参数"><a href="#相关vm参数" class="headerlink" title="相关vm参数"></a>相关vm参数</h3><table>
<thead>
<tr>
<th align="center">含义</th>
<th align="center">参数</th>
</tr>
</thead>
<tbody><tr>
<td align="center">堆初始大小</td>
<td align="center">-Xms</td>
</tr>
<tr>
<td align="center">堆最大大小</td>
<td align="center">-Xmx或-XX:MaxHeapSize&#x3D;size</td>
</tr>
<tr>
<td align="center">新生代大小</td>
<td align="center">-Xmn 或 (-XX:NewSize&#x3D;size + -XX:MaxNewSize&#x3D;size )</td>
</tr>
<tr>
<td align="center">幸存区比例（动态）</td>
<td align="center">-XX:SurvivorRatio&#x3D;ratio和-XX:+UseAdaptiveSizepolicy</td>
</tr>
<tr>
<td align="center">幸存区比例</td>
<td align="center">-XX:SurvivorRatio&#x3D;ratio</td>
</tr>
<tr>
<td align="center">晋升阈值</td>
<td align="center">-XX:MaxTenuringThreshold&#x3D;threshold</td>
</tr>
<tr>
<td align="center">晋升详情</td>
<td align="center">-XX:+PrintTenuringDistribution</td>
</tr>
<tr>
<td align="center">GC详情</td>
<td align="center">-XX:+PrintGCDetails -verbose:gc</td>
</tr>
<tr>
<td align="center">FullGC 前 MinorGC</td>
<td align="center">XX:+ScavengeBeforeFullGC</td>
</tr>
</tbody></table>
<p>幸村区比例：如果新生代是10M,当ratio&#x3D;8时，有8M是划给伊甸园的。剩下两等分，分给from和to。</p>
<p>某个线程的内存溢出了而抛异常（out of memory），不会让其他的线程结束运行。这是因为当一个线程<strong>抛出OOM异常后</strong>，<strong>它所占据的内存资源会全部被释放掉</strong>，从而不会影响其他线程的运行，<strong>进程依然正常</strong></p>
<hr>
<h3 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h3><p>Serial收集器–&gt;Parallel–&gt;Concurrent Mark Sweep(CMS)和Garbage First(G1)收集器–&gt;Shenandoah和ZGC</p>
<hr>
<h4 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h4><p>单线程工作的收集器，他在垃圾收集时，必须暂停其他所有工作，直到他完成收集。</p>
<p>新生代采用复制算法，老生代采用标记整理算法。</p>
<p><img src="/filename/9.png"></p>
<hr>
<h4 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a><strong>ParNew收集器</strong></h4><p>是Serial收集器的<strong>多线程并行版本</strong>，除使用多线程外基本与Serial收集器基本一致。目前只有它与CMS收集器配合工作。Parnew收集器是激活CMS后（使用<code>-XX:+UseConcMarkSweepGC</code>)的默认新生代收集器。</p>
<p><img src="/filename/10.png"></p>
<p><strong>开启串行回收器</strong>：新生代**-Serial** ，老年代-<strong>SerialOld</strong> ，vm参数：<code>XX:+UseSerialGC = Serial + SerialOld</code></p>
<p><img src="/filename/5.png"></p>
<p><strong>安全点</strong>：让其他线程都在这个点停下来，以免垃圾回收时移动对象地址，使得其他线程找不到被移动的对象。安全点位置的选取基本上是以“<strong>是否具有让程序长时间执行的特征</strong>”为标准 进行选定的,例如方法调用、循环跳转、异常跳转 等都属于指令序列复用，所以只有具有这些功能的指令才会产生安全点。</p>
<p><strong>阻塞</strong>：因为是串行的，所以只有一个垃圾回收线程。且在该线程执行回收工作时，其他线程进入<strong>阻塞</strong>状态。</p>
<hr>
<h4 id="吞吐量优先-Parallel-Scavenge收集器"><a href="#吞吐量优先-Parallel-Scavenge收集器" class="headerlink" title="吞吐量优先(Parallel Scavenge收集器)"></a>吞吐量优先(Parallel Scavenge收集器)</h4><p>多线程，堆内存较大，多核CPU。单位时间内，STW的时间最短。总时间最短。</p>
<p><strong>开启垃圾回收器</strong>：vm参数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseParallelGC~-XX:+UseParalleOldGC</span><br></pre></td></tr></table></figure>

<p>1.8都默认开启前者代表是新生代的垃圾回收器，使用的是复制算法；后者工作在老年代，采用标记整理算法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:ParallelGCThreads=n</span><br></pre></td></tr></table></figure>

<p>控制ParallelGC运行时的线程数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseAdaptiveSizePolicy</span><br></pre></td></tr></table></figure>

<p>新生代自适应大小调整策略</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:GCTimeRatio=ratio</span><br></pre></td></tr></table></figure>

<p>调节垃圾回收时间和总时间的占比。1&#x2F;(ratio+1)，垃圾回收总时间占比</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:MaxGCPauseMillis=ms</span><br></pre></td></tr></table></figure>

<p>每次垃圾回收最大暂停毫秒数</p>
<p><img src="/filename/7.png"></p>
<hr>
<h4 id="响应时间优先（CMS"><a href="#响应时间优先（CMS" class="headerlink" title="响应时间优先（CMS)"></a>响应时间优先（CMS)</h4><p>多线程，-堆内存较大，多核CPU。尽可能让单次STW时间最短。适用于关注响应速度的服务</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseConcMarkSweepGC-XX:+UseParNewGC~SerialOld</span><br></pre></td></tr></table></figure>

<p>基于标记清除算法的垃圾回收器。</p>
<p>导致过度内存碎片,分配对象时MinorGC不足，老年代也不足，导致并发失败，CMSGC退化为SerialOld，单线程串行的垃圾回收。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:ParallelGCThreads=n~-XX:ConGCThreads=threads</span><br></pre></td></tr></table></figure>

<p>前者：并行的垃圾回收线程数，一般跟cpu核数一样。</p>
<p>后者：并发的垃圾回收线程数，一般设为并行线程数的四分之一。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:CMSInitiatingOccupancyFraction=percent</span><br></pre></td></tr></table></figure>

<p>作用：并发清理的时候会产生新的垃圾，不能等到内存不足了才去清理。要预留空间给浮动垃圾。值设置的越小，触发时机越早。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+CMSScavengeBeforceRemark</span><br></pre></td></tr></table></figure>

<p>作用：在重新标记前对新生代的进行垃圾回收，新生代存活对象少，减轻重新标记压力。（+打开，-关闭）</p>
<p><img src="/filename/8.png"></p>
<p>初始标记只会列举根对象，非常快。用户线程就会恢复运行，垃圾回收线程就会并发标记，把剩余垃圾标记。重新标记再次STW，因为在之前那并发标记期间存在新的引用，影响标记。</p>
<hr>
<h4 id="Young-Colletion跨代引用"><a href="#Young-Colletion跨代引用" class="headerlink" title="Young Colletion跨代引用"></a>Young Colletion跨代引用</h4><p>简单叙述：老年代数据比较多，一个个遍历找跟对象很麻烦，那就把是根的对象的用一张卡记录，记录和新生代的关系，这样新生代中找跟对象就直接查卡，减少找寻的时间</p>
<p>采用了cart table的方式，对老年代进行细分，分成了许多个card,每个card大约是512K。如果老年代某个对象，引用了新生代的对象，我们把这个老年代的对象标记为脏card。脏card不会立即更新，会把更新指令放在queue中。0-0-记忆集可以理解为一种规范，卡表理解为一种具体的实现方式，CMS只有唯一一个卡表（新生代维护），G1每个region都必须有一份卡表</p>
<hr>
<h4 id="并发可达性分析"><a href="#并发可达性分析" class="headerlink" title="并发可达性分析"></a>并发可达性分析</h4><p>产生“对象消失”的问题的两个条件</p>
<ul>
<li>赋值器插入了一条或多条从黑色对象到白色对象的引用。</li>
<li>赋值器删除了全部从灰色对象到该白色对象的直接或间接引用。</li>
</ul>
<p>可以通过<strong>增量更新</strong>（Incremental Update）和<strong>原始快照</strong>（Snapshot At The Beginning，SATB）</p>
<p>增量更新破坏的是第一个条件：当黑色对象插入新的指向白色对象的引用关系时，就将这个新插入的引用记录下来，等并发扫描结束后，再将这些记录过引用关系中的黑色对象为根，重新扫描。可理解为黑色对象插入指向白色对象的饮用后，变为灰色。</p>
<p>原始快照破坏第二个条件：当灰色对象要删除指向白色对象的的引用关系时，将这个要删除的引用记录下来，等并发扫描后，再将这些记录过引用关系的灰色对象为根，重新扫描。</p>
<p>引用关系记录的插入还是删除，虚拟机的记录操作都是通过写屏障是实现的。G1、Shenandoah使用原始快照。</p>
<hr>
<p>写屏障</p>
<p>当灰色对象要删除指向白色对象的的引用关系时，就会触发写屏障机制，将这个要删除的引用记录下来写到本地对象中。然后写进全局队列 </p>
<h4 id="Garbage-First收集器"><a href="#Garbage-First收集器" class="headerlink" title="Garbage First收集器"></a>Garbage First收集器</h4><p>在G1收集器出现之前，包括cms在内，垃圾收集器的目标范围要么是新生代（Minor GC），要么是老年代（Major GC)，要么就是整个java堆（Full GC）。而G1可以面向堆内存的任何部分来组成回收集进行回收，衡量标准不再是它属于哪个分代，而是哪块内存存放垃圾最多，回收收益最大，这就是G1的Mixed GC模式。注意：G1仍遵循分代收集理论。</p>
<p>G1的关键基于Region的堆内存布局。G1把连续的堆内存划分为多个大小相等的独立区域（Region)，每个region都可以根据需要成为Eden，Survivor空间，或者是老年代空间。region还存在一类特殊的Humongous区域，专门存储大对象，G1大多数行为把它当作老年代一部分看待。</p>
<blockquote>
<p><strong>Young Collection–&gt;YoungCollection+Concurrent Mark–&gt;Mixed Collection–&gt;Young Collection</strong></p>
</blockquote>
<p><img src="/1.jpg"></p>
<h6 id="Young-Collection"><a href="#Young-Collection" class="headerlink" title="Young Collection"></a>Young Collection</h6><p>新创建的对象一开始放在Eden区域，当逐渐被占满，触发一次垃圾回收（当然和其他一样有<strong>STW</strong>，但比较短），以<strong>copy的算法</strong>放入幸存区。一定情况下（上面已说明）幸存区会触发垃圾回收（部分进入老年代）</p>
<hr>
<h6 id="YoungCollection-Concurrent-Mark"><a href="#YoungCollection-Concurrent-Mark" class="headerlink" title="YoungCollection+Concurrent Mark"></a>YoungCollection+Concurrent Mark</h6><p>在新生代GC时会进行GC Root的初始标记。</p>
<p>老年代占用堆空间达到阈值时，进行并发标记（no STW），vm参数：     <code>-XX:InitiatingHeapOccupancyPercent=percent</code>。</p>
<hr>
<h6 id="Mixed-Collection"><a href="#Mixed-Collection" class="headerlink" title="Mixed Collection"></a>Mixed Collection</h6><p>并发标记后，老年代也要回收，部分老年会通过复制算法复制到新的老年代区（多少取决于设置的暂停时间<code>-XX:MaxGCPauseMillis=ms</code>)。</p>
<hr>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/09/12/%E5%85%AB%E8%82%A1%E6%88%91%E7%A2%B0%E5%88%B0%E7%9A%84%E5%9C%A8springboot/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="LLCH Liu">
      <meta itemprop="description" content="Here we go!!!!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Here We Go">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/09/12/%E5%85%AB%E8%82%A1%E6%88%91%E7%A2%B0%E5%88%B0%E7%9A%84%E5%9C%A8springboot/" class="post-title-link" itemprop="url">八股我碰到的在springboot</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-09-12 21:56:15" itemprop="dateCreated datePublished" datetime="2023-09-12T21:56:15+08:00">2023-09-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-09-13 19:52:19" itemprop="dateModified" datetime="2023-09-13T19:52:19+08:00">2023-09-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%85%AB%E8%82%A1/" itemprop="url" rel="index"><span itemprop="name">-八股</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="websocket（来源heima）"><a href="#websocket（来源heima）" class="headerlink" title="websocket（来源heima）"></a>websocket（来源heima）</h3><p>WebSocket 是基于 TCP 的一种新的<strong>网络协议</strong>。它实现了浏览器与服务器全双工通信——浏览器和服务器只需要完成一次握手，两者之间就可以创建<strong>持久性</strong>的连接， 并进行<strong>双向</strong>数据传输。</p>
<p>实现览器与服务器全双工通信。浏览器既可以向服务器发送消息，服务器也可主动向浏览器推送消息。</p>
<p><strong>HTTP协议和WebSocket协议对比：</strong></p>
<ul>
<li>HTTP是<strong>短连接</strong></li>
<li>WebSocket是<strong>长连接</strong></li>
<li>HTTP通信是<strong>单向</strong>的，基于请求响应模式</li>
<li>WebSocket支持<strong>双向</strong>通信</li>
<li>HTTP和WebSocket底层都是TCP连接</li>
</ul>
<p><strong>WebSocket缺点：</strong></p>
<p>服务器长期维护长连接需要一定的成本<br>各个浏览器支持程度不一<br>WebSocket 是长连接，受网络限制比较大，需要处理好重连</p>
<p><strong>WebSocket应用场景：</strong></p>
<p>1). 视频弹幕</p>
<p>2). 网页聊天</p>
<p>3). 体育实</p>
<p>4). 股票基金报价实时更新况更新</p>
<p><strong>实现步骤：</strong></p>
<p>1). 直接使用websocket.html页面作为WebSocket客户端</p>
<p>2). 导入WebSocket的maven坐标</p>
<p>3). 导入WebSocket服务端组件WebSocketServer，用于和客户端通信</p>
<p>4). 导入配置类WebSocketConfiguration，注册WebSocket的服务端组件</p>
<p>5). 导入定时任务类WebSocketTask，定时向客户端推送数据</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/09/07/Hello-world/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="LLCH Liu">
      <meta itemprop="description" content="Here we go!!!!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Here We Go">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/09/07/Hello-world/" class="post-title-link" itemprop="url">底斯堡演讲</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-09-07 17:45:52 / 修改时间：18:11:11" itemprop="dateCreated datePublished" datetime="2023-09-07T17:45:52+08:00">2023-09-07</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%8B%B1%E6%96%87%E6%BC%94%E8%AE%B2/" itemprop="url" rel="index"><span itemprop="name">-英文演讲</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Four score and seven years ago our fathers brought forth on this continent, a new nation, conceived in Liberty, and dedicated to the proposition that all men are created equal.</p>
<p>Now we are engaged in a great civil war, testing whether that nation, or any nation so conceived and so dedicated, can long endure. We are met on a great battle-field of that war. We have come to dedicate a portion of that field, as a final resting place for those who here gave their lives that that nation might live. It is altogether fitting and proper that we should do this.</p>
<p>But, in a larger sense, we can not dedicate—we can not consecrate—we can not hallow—this ground. The brave men, living and dead, who struggled here, have consecrated it, far above our poor power to add or detract. The world will little note, nor long remember what we say here, but it can never forget what they did here. It is for us the living, rather, to be dedicated here to the unfinished work which they who fought here have thus far so nobly advanced. It is rather for us to be here dedicated to the great task remaining before us—that from these honored dead we take increased devotion to that cause for which they gave the last full measure of devotion—that we here highly resolve that these dead shall not have died in vain—that this nation, under God, shall have a new birth of freedom—and that government of the people, by the people, for the people, shall not perish from the earth.</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">LLCH Liu</p>
  <div class="site-description" itemprop="description">Here we go!!!!</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">8</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">LLCH Liu</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

    <span id="busuanzi_container_site_pv">总访问量<span id="busuanzi_value_site_pv"></span>次</span>
    <span class="post-meta-divider">|</span>
    <span id="busuanzi_container_site_uv">总访客数<span id="busuanzi_value_site_uv"></span>人</span>
    <span class="post-meta-divider">|</span>
<!-- 不蒜子计数初始值纠正 -->
<script>
$(document).ready(function() {

    var int = setInterval(fixCount, 50);  // 50ms周期检测函数
    var countOffset = 20000;  // 初始化首次数据

    function fixCount() {            
       if (document.getElementById("busuanzi_container_site_pv").style.display != "none")
        {
            $("#busuanzi_value_site_pv").html(parseInt($("#busuanzi_value_site_pv").html()) + countOffset); 
            clearInterval(int);
        }                  
        if ($("#busuanzi_container_site_pv").css("display") != "none")
        {
            $("#busuanzi_value_site_uv").html(parseInt($("#busuanzi_value_site_uv").html()) + countOffset); // 加上初始数据 
            clearInterval(int); // 停止检测
        }  
    }
       	
});
</script> 








        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  


</body>
</html>
