<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"livere","storage":true,"lazyload":false,"nav":null,"activeClass":"livere"},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="Here we go!!!!">
<meta property="og:type" content="website">
<meta property="og:title" content="Here We Go">
<meta property="og:url" content="http://example.com/default-index/index.html">
<meta property="og:site_name" content="Here We Go">
<meta property="og:description" content="Here we go!!!!">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="LLCH Liu">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/default-index/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Here We Go</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Here We Go</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/home/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-resources">

    <a href="/resources/" rel="section"><i class="download fa-fw"></i>resources</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/10/02/Nacos/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="LLCH Liu">
      <meta itemprop="description" content="Here we go!!!!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Here We Go">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/10/02/Nacos/" class="post-title-link" itemprop="url">Nacos</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-10-02 14:24:37" itemprop="dateCreated datePublished" datetime="2023-10-02T14:24:37+08:00">2023-10-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-10-04 17:29:47" itemprop="dateModified" datetime="2023-10-04T17:29:47+08:00">2023-10-04</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Nacos前置配置知识"><a href="#Nacos前置配置知识" class="headerlink" title="Nacos前置配置知识"></a>Nacos前置配置知识</h1><p>nacos首先是个注册中心，其次还是个数据中心</p>
<p><strong>启动命令</strong></p>
<p>windows 启动命令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">startup.cmd -m standalone</span><br></pre></td></tr></table></figure>

<p>Linux启动命令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh startup.sh -m standalone</span><br></pre></td></tr></table></figure>

<h2 id="Nacos依赖"><a href="#Nacos依赖" class="headerlink" title="Nacos依赖"></a>Nacos依赖</h2><p>父工程</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-alibaba-dependencies&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.2.5.RELEASE&lt;/version&gt;</span><br><span class="line">    &lt;type&gt;pom&lt;/type&gt;</span><br><span class="line">    &lt;scope&gt;import&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>客户端</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- nacos客户端依赖包 --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>





<h1 id="服务分级存储模型"><a href="#服务分级存储模型" class="headerlink" title="服务分级存储模型"></a>服务分级存储模型</h1><h2 id="配置集群"><a href="#配置集群" class="headerlink" title="配置集群"></a>配置集群</h2><p>给user-service配置集群</p>
<p>修改user-service的application.yml文件，添加集群配置：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="string">localhost:8848</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">cluster-name:</span> <span class="string">HZ</span> <span class="comment"># 集群名称</span></span><br></pre></td></tr></table></figure>



<h2 id="同集群优先的负载均衡"><a href="#同集群优先的负载均衡" class="headerlink" title="同集群优先的负载均衡"></a>同集群优先的负载均衡</h2><p>默认的<code>ZoneAvoidanceRule</code>并不能实现根据同集群优先来实现负载均衡。</p>
<p>因此Nacos中提供了一个<code>NacosRule</code>的实现，可以优先从同集群中挑选实例。</p>
<p>1）给order-service配置集群信息</p>
<p>修改order-service的application.yml文件，添加集群配置</p>
<p>2）<strong>修改负载均衡规则，不修改就还是轮询</strong></p>
<p>修改order-service的application.yml文件，修改负载均衡规则：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">userservice:</span></span><br><span class="line">  <span class="attr">ribbon:</span></span><br><span class="line">    <span class="attr">NFLoadBalancerRuleClassName:</span> <span class="string">com.alibaba.cloud.nacos.ribbon.NacosRule</span> <span class="comment"># 负载均衡规则 </span></span><br></pre></td></tr></table></figure>



<h2 id="权重配置"><a href="#权重配置" class="headerlink" title="权重配置"></a>权重配置</h2><p>实际部署中会出现这样的场景：</p>
<p>服务器设备性能有差异，部分实例所在机器性能较好，另一些较差，我们希望性能好的机器承担更多的用户请求。</p>
<p>但默认情况下NacosRule是同集群内随机挑选，不会考虑机器的性能问题。</p>
<p>因此，Nacos提供了权重配置来控制访问频率，权重越大则访问频率越高。 </p>
<ol>
<li><p>在nacos控制台，找到user-service的实例列表，点击编辑，即可修改权重</p>
</li>
<li><p>在弹出的编辑窗口，修改权重</p>
</li>
</ol>
<h2 id="环境隔离"><a href="#环境隔离" class="headerlink" title="环境隔离"></a>环境隔离</h2><p>Nacos提供了namespace来实现环境隔离功能。</p>
<ul>
<li>nacos中可以有多个namespace</li>
<li>namespace下可以有group、service等</li>
<li>不同namespace之间相互隔离，例如不同namespace的服务互相不可见</li>
</ul>
<h3 id="给微服务配置namespace"><a href="#给微服务配置namespace" class="headerlink" title="给微服务配置namespace"></a>给微服务配置namespace</h3><p>给微服务配置namespace只能通过修改配置来实现。</p>
<p>例如，修改order-service的application.yml文件：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="string">localhost:8848</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">cluster-name:</span> <span class="string">HZ</span></span><br><span class="line">        <span class="attr">namespace:</span> <span class="string">492a7d5d-237b-46a1-a99a-fa8e98e4b0f9</span> <span class="comment"># 命名空间，填ID</span></span><br></pre></td></tr></table></figure>



<h2 id="Nacos和Eureka差异"><a href="#Nacos和Eureka差异" class="headerlink" title="Nacos和Eureka差异"></a>Nacos和Eureka差异</h2><p>Nacos的服务实例分为两种l类型：</p>
<ul>
<li>临时实例：如果实例宕机超过一定时间，会从服务列表剔除，默认的类型。</li>
<li><strong>非临时实例：如果实例宕机，不会从服务列表剔除，也可以叫永久实例。</strong></li>
</ul>
<p>Nacos和Eureka整体结构类似，服务注册、服务拉取、心跳等待，但是也存在一些差异：</p>
<p><img src="/filename/30.png"></p>
<ul>
<li><p>Nacos与eureka的共同点</p>
<ul>
<li>都支持服务注册和服务拉取</li>
<li>都支持服务提供者心跳方式做健康检测</li>
</ul>
</li>
<li><p>Nacos与Eureka的区别</p>
<ul>
<li>Nacos支持服务端主动检测提供者状态：临时实例采用心跳模式，非临时实例采用主动检测模式</li>
<li>临时实例心跳不正常会被剔除，非临时实例则不会被剔除</li>
<li>Nacos支持服务列表变更的消息推送模式，服务列表更新更及时</li>
<li>Nacos集群默认采用AP方式，当集群中存在非临时实例时，采用CP模式；Eureka采用AP方式</li>
</ul>
</li>
</ul>
<h1 id="Nacos配置管理"><a href="#Nacos配置管理" class="headerlink" title="Nacos配置管理"></a>Nacos配置管理</h1><p>配置获取时，<strong>bootstrap.yml</strong>会比application.yml更早读取。</p>
<p>加载bootstrap.yaml，获取nacos地址，配置文件id，根据id去nacos获取配置，加载本地配置与nacos拉取的配置合并。</p>
<p>1）引入nacos-config依赖</p>
<p>首先，在user-service服务中，引入nacos-config的客户端依赖：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&lt;!--nacos配置管理依赖--&gt;</span></span><br><span class="line"><span class="string">&lt;dependency&gt;</span></span><br><span class="line">    <span class="string">&lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span></span><br><span class="line">    <span class="string">&lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;/artifactId&gt;</span></span><br><span class="line"><span class="string">&lt;/dependency&gt;</span></span><br></pre></td></tr></table></figure>

<p>之前引入的时discovery，也就是服务发现，这里是config就是配置管理</p>
<p>2）添加bootstrap.yaml</p>
<p>然后，在user-service中添加一个bootstrap.yaml文件，内容如下：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">userservice</span> <span class="comment"># 服务名称</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">dev</span> <span class="comment">#开发环境，这里是dev </span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="string">localhost:8848</span> <span class="comment"># Nacos地址</span></span><br><span class="line">      <span class="attr">config:</span></span><br><span class="line">        <span class="attr">file-extension:</span> <span class="string">yaml</span> <span class="comment"># 文件后缀名</span></span><br></pre></td></tr></table></figure>

<p>这里会根据spring.cloud.nacos.server-addr获取nacos地址，再根据</p>
<p><code>$&#123;spring.application.name&#125;-$&#123;spring.profiles.active&#125;.$&#123;spring.cloud.nacos.config.file-extension&#125;</code>作为文件id，来读取配置。</p>
<p>本例中，就是去读取<code>userservice-dev.yaml</code>：</p>
<p><img src="/filename/image-20210714170845901.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;pattern.dateformat&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String dateformat;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@GetMapping(&quot;now&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">now</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> LocalDateTime.now().format(DateTimeFormatter.ofPattern(dateformat));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="配置热更新"><a href="#配置热更新" class="headerlink" title="配置热更新"></a>配置热更新</h3><p>方式一</p>
<p>在@Value注入的变量所在类上添加注解@RefreshScope</p>
<p>方式二</p>
<p>使用@ConfigurationProperties注解代替@Value注解。</p>
<p>在user-service服务中，添加一个类，读取patterrn.dateformat属性</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.user.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.context.properties.ConfigurationProperties;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;pattern&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PatternProperties</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String dateformat;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在UserController中使用这个类代替@Value：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> PatternProperties patternProperties;<span class="comment">//替代value</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;now&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">now</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> LocalDateTime.now().format(DateTimeFormatter.ofPattern(patternProperties.getDateformat()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/09/28/springcloud/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="LLCH Liu">
      <meta itemprop="description" content="Here we go!!!!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Here We Go">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/09/28/springcloud/" class="post-title-link" itemprop="url">springcloud</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-09-28 10:35:18" itemprop="dateCreated datePublished" datetime="2023-09-28T10:35:18+08:00">2023-09-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-10-01 23:16:17" itemprop="dateModified" datetime="2023-10-01T23:16:17+08:00">2023-10-01</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>随着服务越来越多，代码耦合越来越多。所以大型互联网项目必须去做拆分。把大型项目拆分为多个独立的项目，每个项目完成独立的一部分，将来独立开发部署。一个大业务需要多个服务完成。</p>
<p>微服务中还有一个组件叫做注册中心，可以记录微服务中每一个服务的IP的端口以及能干什么事得信息</p>
<p><img src="/filename/26.png"></p>
<p>分布式架构：</p>
<p>根据业务做拆分，每个业务模块作为独立项目开发，称为一个服务。</p>
<p>微服务就是一种分布式架构方案。其特征：</p>
<ul>
<li><p>单一职责：微服务拆分粒度更小，每一个服务都对应唯一的业务能力，做到单一职责，避免重复业务开发。</p>
</li>
<li><p>面向服务：微服务对外暴露业务接口。</p>
</li>
<li><p>自治：团队独立，技术独立，数据独立，部署独立。</p>
<p>数据独立是指每个服务有自己的数据库</p>
</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>Dubbo</th>
<th>SpringCloud</th>
<th>SpringCloudAlibaba</th>
</tr>
</thead>
<tbody><tr>
<td>注册中心</td>
<td>zookeeper、Redis</td>
<td>Eureka、Consul</td>
<td>Nacos、Eureka</td>
</tr>
<tr>
<td>服务远程调用</td>
<td>Dubbo协议</td>
<td>Feign（HTTP协议，服务接口Restful风格）</td>
<td>Dubbo、Feign</td>
</tr>
<tr>
<td>配置中心</td>
<td>无</td>
<td>SpringCloudConfig</td>
<td>SpringCloudConfig、Nacos</td>
</tr>
<tr>
<td>服务网关</td>
<td>无</td>
<td>SpringCloudGateway、Zuul</td>
<td>SpringCloudGateway、Zuul</td>
</tr>
<tr>
<td>服务监控保护</td>
<td>dubbo-admin、功能弱</td>
<td>Hystrix</td>
<td>Sentinel</td>
</tr>
</tbody></table>
<h1 id="微服务远程调用"><a href="#微服务远程调用" class="headerlink" title="微服务远程调用"></a>微服务远程调用</h1><p>修改order-service中的根据id查询订单业务，要求在查询订单的同时，根据订单中包含的userId查询出用户信息，一起返回。</p>
<p>因此，我们需要在order-service中 向user-service发起一个http的请求，调用<a target="_blank" rel="noopener" href="http://localhost:8081/user/%7BuserId%7D%E8%BF%99%E4%B8%AA%E6%8E%A5%E5%8F%A3%E3%80%82">http://localhost:8081/user/{userId}这个接口。</a></p>
<p>大概的步骤是这样的：</p>
<ul>
<li>注册一个<code>RestTemplate</code>的实例到Spring容器</li>
<li>修改<code>order-service</code>服务中的<code>OrderService</code>类中的<code>queryOrderById</code>方法，根据<code>Order</code>对象中的<code>userId</code>查询<code>User</code></li>
<li>将查询的<code>User</code>填充到<code>Order</code>对象，一起返回</li>
</ul>
<h2 id="具体流程"><a href="#具体流程" class="headerlink" title="具体流程"></a>具体流程</h2><h3 id="注册RestTemplate"><a href="#注册RestTemplate" class="headerlink" title="注册RestTemplate"></a>注册RestTemplate</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MapperScan(&quot;cn.itcast.order.mapper&quot;)</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(OrderApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RestTemplate <span class="title function_">restTemplate</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RestTemplate</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="实现远程调用"><a href="#实现远程调用" class="headerlink" title="实现远程调用"></a>实现远程调用</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class OrderService &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private OrderMapper orderMapper;</span><br><span class="line">    @Autowired</span><br><span class="line">    private RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public Order queryOrderById(Long orderId) &#123;</span><br><span class="line">        // 1.查询订单</span><br><span class="line">        Order order = orderMapper.findById(orderId);</span><br><span class="line">        //2.利用RestTemplate发送http请求，调用用户</span><br><span class="line">        String url =&quot;http://localhost:8081/user/&quot; + order.getUserId();</span><br><span class="line">//        发起调用</span><br><span class="line">        User user = restTemplate.getForObject(url, User.class);</span><br><span class="line">//        存入order</span><br><span class="line">        order.setUser(user);</span><br><span class="line">        // 4.返回</span><br><span class="line">        return order;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>总结：</p>
<p>跨服调用其实就是发送一次<code>http</code>请求。首先，向spring容器注入<code>restTemplate</code>对象。其次利用<code>restTemplate</code>里的<code>getForObject</code></p>
<h1 id="Eureka注册中心"><a href="#Eureka注册中心" class="headerlink" title="Eureka注册中心"></a>Eureka注册中心</h1><h2 id="Eureka解决的问题"><a href="#Eureka解决的问题" class="headerlink" title="Eureka解决的问题"></a>Eureka解决的问题</h2><p>以下问题都需要利用SpringCloud中的注册中心来解决，其中最广为人知的注册中心就是Eureka。</p>
<ul>
<li>order-service在发起远程调用的时候，该如何得知user-service实例的ip地址和端口？</li>
<li>有多个user-service实例地址，order-service调用时该如何选择？</li>
<li>order-service如何得知某个user-service实例是否依然健康，是不是已经宕机？</li>
</ul>
<p><strong>问题1：order-service如何得知user-service实例地址？</strong></p>
<p>获取地址信息的流程如下：</p>
<ul>
<li><strong>user-service服务实例启动后</strong>，将自己的信息注册到eureka-server（Eureka服务端）。这个叫服务注册</li>
<li><strong>eureka-server保存</strong>服务名称到服务实例地址列表的映射关系</li>
<li><strong>order-service根据服务名称，拉取</strong>实例地址列表。这个叫服务发现或服务拉取</li>
</ul>
<p><strong>问题2：order-service如何从多个user-service实例中选择具体的实例？</strong></p>
<ul>
<li>order-service从实例列表中利用负载均衡算法选中一个实例地址</li>
<li>向该实例地址发起远程调用</li>
</ul>
<p><strong>问题3：order-service如何得知某个user-service实例是否依然健康，是不是已经宕机？</strong></p>
<ul>
<li>user-service会每隔一段时间（默认30秒）向eureka-server发起请求，报告自己状态，称为心跳</li>
<li>当超过一定时间没有发送心跳时，eureka-server会认为微服务实例故障，将该实例从服务列表中剔除</li>
<li>order-service拉取服务时，就能将故障实例排除了</li>
</ul>
<h2 id="Eureka实践"><a href="#Eureka实践" class="headerlink" title="Eureka实践"></a>Eureka实践</h2><h3 id="创建euraka-server服务"><a href="#创建euraka-server服务" class="headerlink" title="创建euraka-server服务"></a>创建euraka-server服务</h3><ul>
<li>引入eureka依赖</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>编写启动类</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EurekaApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(EurekaApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>编写配置文件</p>
<p>编写个application.yml文件</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 10086</span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: eureka-server</span><br><span class="line">eureka:</span><br><span class="line">  client:</span><br><span class="line">    service-url: </span><br><span class="line">      defaultZone: http://127.0.0.1:10086/eureka</span><br></pre></td></tr></table></figure>

<h3 id="服务注册"><a href="#服务注册" class="headerlink" title="服务注册"></a>服务注册</h3><p>例如：下面，我们将user-service注册到eureka-server中去。</p>
<ul>
<li><p>引入依赖</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>加注解</p>
<p>给eureka-server服务编写一个启动类，一定要添加一个@EnableEurekaServer注解，开启eureka的注册中心功能：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.eureka;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EurekaApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(EurekaApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>配置文件在</p>
<p>user-service中，修改application.yml文件，添加服务名称、eureka地址：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: userservice</span><br><span class="line">eureka:</span><br><span class="line">  client:</span><br><span class="line">    service-url:</span><br><span class="line">      defaultZone: http://127.0.0.1:10086/eureka</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="Ribbon负载均衡"><a href="#Ribbon负载均衡" class="headerlink" title="Ribbon负载均衡"></a>Ribbon负载均衡</h2><p>添加了@LoadBalanced注解，即可实现负载均衡功能。</p>
<p>在order-service的OrderApplication中，给RestTemplate这个Bean添加一个@LoadBalanced注解</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MapperScan(&quot;cn.itcast.order.mapper&quot;)</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(OrderApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@LoadBalanced</span></span><br><span class="line">    <span class="keyword">public</span> RestTemplate <span class="title function_">restTemplate</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RestTemplate</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="负载均衡Ribbon流程"><a href="#负载均衡Ribbon流程" class="headerlink" title="负载均衡Ribbon流程"></a>负载均衡Ribbon流程</h3><p>order service发起请求，请求user的数据，会被<code>LoadBanlanceInterceptor</code>负载均衡拦截器拦住，拦住之后会得到请求中的服务名称（user service），然后交给<code>RibbonLoadBanlancerClient</code>，而它会把服务交给<code>DynamicServerListLoadBalancer</code>,而它回去ereka拉取服务列表，得到多个服务的信息，而后要在这里面挑一个做负载均衡，是通过IRule会在服务列表里基于规则做出选择，然后将值返回给<code>RibbonLoadBanlancerClient</code>，而<code>RibbonLoadBanlancerClient</code>就会用这个返回的ip和端口替换服务名称，得到真实请求地址</p>
<p><img src="/filename/29.png"></p>
<p>基本流程如下：</p>
<ul>
<li>拦截我们的RestTemplate请求<a target="_blank" rel="noopener" href="http://userservice/user/1">http://userservice/user/1</a></li>
<li>RibbonLoadBalancerClient会从请求url中获取服务名称，也就是user-service</li>
<li>DynamicServerListLoadBalancer根据user-service到eureka拉取服务列表</li>
<li>eureka返回列表，localhost:8081、localhost:8082</li>
<li>IRule利用内置负载均衡规则，从列表中选择一个，例如localhost:8081</li>
<li>RibbonLoadBalancerClient修改请求地址，用localhost:8081替代userservice，得到<a target="_blank" rel="noopener" href="http://localhost:8081/user/1%EF%BC%8C%E5%8F%91%E8%B5%B7%E7%9C%9F%E5%AE%9E%E8%AF%B7%E6%B1%82">http://localhost:8081/user/1，发起真实请求</a></li>
</ul>
<h3 id="负载均衡策略"><a href="#负载均衡策略" class="headerlink" title="负载均衡策略"></a>负载均衡策略</h3><p><strong>IRule</strong>有哪些实现，我们将如何修改它的实现</p>
<ul>
<li>代码方式：在order-service中的OrderApplication类中，定义一个新的IRule</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> IRule <span class="title function_">randomRule</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RandomRule</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>配置文件方式：在order-service的application.yml文件中，添加新的配置也可以修改规则：</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">userservice:</span> <span class="comment"># 给某个微服务配置负载均衡规则，这里是userservice服务</span></span><br><span class="line">  <span class="attr">ribbon:</span></span><br><span class="line">    <span class="attr">NFLoadBalancerRuleClassName:</span> <span class="string">com.netflix.loadbalancer.RandomRule</span> <span class="comment"># 负载均衡规则 </span></span><br></pre></td></tr></table></figure>





<h3 id="饥饿加载"><a href="#饥饿加载" class="headerlink" title="饥饿加载"></a>饥饿加载</h3><p>Ribbon默认是采用懒加载，即第一次访问时才会去创建LoadBalanceClient，请求时间会很长。</p>
<p>而饥饿加载则会在项目启动时创建，降低第一次访问的耗时，通过下面配置开启饥饿加载：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ribbon:</span><br><span class="line">  eager-load:</span><br><span class="line">    enabled: <span class="literal">true</span></span><br><span class="line">    clients: userservice</span><br></pre></td></tr></table></figure>










      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/09/28/springboot/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="LLCH Liu">
      <meta itemprop="description" content="Here we go!!!!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Here We Go">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/09/28/springboot/" class="post-title-link" itemprop="url">springboot</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-09-28 10:34:15 / 修改时间：10:34:57" itemprop="dateCreated datePublished" datetime="2023-09-28T10:34:15+08:00">2023-09-28</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/09/25/java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="LLCH Liu">
      <meta itemprop="description" content="Here we go!!!!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Here We Go">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/09/25/java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/" class="post-title-link" itemprop="url">java内存模型</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-09-25 15:28:54" itemprop="dateCreated datePublished" datetime="2023-09-25T15:28:54+08:00">2023-09-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-09-27 16:55:37" itemprop="dateModified" datetime="2023-09-27T16:55:37+08:00">2023-09-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JVM/" itemprop="url" rel="index"><span itemprop="name">-JVM</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>简单的说，JMM 定义了一套在多线程环境下读写共享数据时（成员变量、数组）时，对数据的可见性、有序 性、和原子性的规则和保障。和内存结构没什么关系</p>
<p>原子性还要保证数据能及时从工作内存返回到主内存，期间不被其他线程抢占cpu</p>
<h1 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h1><p>问题提出，两个线程对初始值为 0 的静态变量一个做自增，一个做自减，各做 5000 次，结果不一定是 0。</p>
<p><img src="/filename/24.png"></p>
<p>如果是单线程以上 8 行代码是顺序执行（不会交错）没有问题：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 假设i的初始值为0</span><br><span class="line">getstatic i // 线程1-获取静态变量i的值 线程内i=0</span><br><span class="line">iconst_1 // 线程1-准备常量1</span><br><span class="line">iadd // 线程1-自增 线程内i=1</span><br><span class="line">putstatic i // 线程1-将修改后的值存入静态变量i 静态变量i=1</span><br><span class="line">getstatic i // 线程1-获取静态变量i的值 线程内i=1</span><br><span class="line">iconst_1 // 线程1-准备常量1</span><br><span class="line">isub // 线程1-自减 线程内i=0</span><br><span class="line">putstatic i // 线程1-将修改后的值存入静态变量i 静态变量i=0</span><br></pre></td></tr></table></figure>

<p>但多线程下这 8 行代码可能交错运行： </p>
<p>出现负数的情况：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 假设i的初始值为0</span><br><span class="line">getstatic i // 线程1-获取静态变量i的值 线程内i=0</span><br><span class="line">getstatic i // 线程2-获取静态变量i的值 线程内i=0</span><br><span class="line">iconst_1 // 线程1-准备常量1</span><br><span class="line">iadd // 线程1-自增 线程内i=1</span><br><span class="line">putstatic i // 线程1-将修改后的值存入静态变量i 静态变量i=1</span><br><span class="line">iconst_1 // 线程2-准备常量1</span><br><span class="line">isub // 线程2-自减 线程内i=-1</span><br><span class="line">putstatic i // 线程2-将修改后的值存入静态变量i 静态变量i=-1</span><br></pre></td></tr></table></figure>

<p>出现正数的情况：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 假设i的初始值为0</span><br><span class="line">getstatic i // 线程1-获取静态变量i的值 线程内i=0</span><br><span class="line">getstatic i // 线程2-获取静态变量i的值 线程内i=0</span><br><span class="line">iconst_1 // 线程1-准备常量1</span><br><span class="line">iadd // 线程1-自增 线程内i=1</span><br><span class="line">iconst_1 // 线程2-准备常量1</span><br><span class="line">isub // 线程2-自减 线程内i=-1</span><br><span class="line">putstatic i // 线程2-将修改后的值存入静态变量i 静态变量i=-1</span><br><span class="line">putstatic i // 线程1-将修改后的值存入静态变量i 静态变量i=1</span><br></pre></td></tr></table></figure>

<h2 id="解决方法："><a href="#解决方法：" class="headerlink" title="解决方法："></a>解决方法：</h2><p><code>synchronized（</code>同步关键字）同一时刻只有一个线程进入同步代码块</p>
<p>语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">synchronized( 对象 ) &#123;</span><br><span class="line">要作为原子操作代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用 <code>synchronized</code> 解决并发问题：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"><span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">5000</span>; j++) &#123;</span><br><span class="line"><span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">5000</span>; j++) &#123;</span><br><span class="line"><span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">i--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">t1.start();</span><br><span class="line">t2.start();</span><br><span class="line">t1.join();</span><br><span class="line">t2.join();</span><br><span class="line">System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h1><p>因为 t 线程要频繁从主内存中读取 run 的值，JIT 编译器会将 run 的值缓存至自己工作内存中的高 速缓存中，减少对主存中 run 的访问，提高效率</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">run</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span>(run) &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        log.info(<span class="string">&quot;t1 Stop&quot;</span>);</span><br><span class="line">        run = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>首先 t1 线程运行，然后过一秒，主线程设置 run 的值为 false，想让 t1 线程停止下来，但是 t1 线程并没有停，分析如下图：</p>
<p><img src="/filename/19.png"></p>
<h2 id="解决方法：-1"><a href="#解决方法：-1" class="headerlink" title="解决方法："></a>解决方法：</h2><ul>
<li><p>volatile（易变关键字） 它可以用来修饰成员变量和静态成员变量，他可以避免线程从自己的工作缓存中查找变量的值，必须到<strong>主存</strong>中获取它的值，线程操作 volatile 变量都是直接操作主存</p>
</li>
<li><p>volatile内部实现机制就是MESI协议，应该是先判断该变量的缓存行状态是否失效，如果失效，才会重新从内存中读取该变量的值，而不是每次都从内存中读取。</p>
</li>
<li><p>synchronized保证可见性，原子性，有序性</p>
</li>
<li><p>synchronized获取锁会从主存刷新值，释放锁也会将修改的值刷新到主存，保证了可见性</p>
</li>
<li><p>因为println加了synchronized，synchronized会先清理缓存再读</p>
</li>
</ul>
<h1 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// volatile 修饰的变量，可以禁用指令重排 volatile boolean ready = false; 可以防止变量之前的代码被重排序</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">ready</span> <span class="operator">=</span> <span class="literal">false</span>; </span><br><span class="line"><span class="comment">// 线程1 执行此方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actor1</span><span class="params">(I_Result r)</span> &#123;</span><br><span class="line"> <span class="keyword">if</span>(ready) &#123;</span><br><span class="line"> 	r.r1 = num + num;</span><br><span class="line"> &#125; </span><br><span class="line"> <span class="keyword">else</span> &#123;</span><br><span class="line"> 	r.r1 = <span class="number">1</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 线程2 执行此方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actor2</span><span class="params">(I_Result r)</span> &#123;</span><br><span class="line"> num = <span class="number">2</span>;</span><br><span class="line"> ready = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在多线程环境下，以上的代码 r1 的值有三种情况：<br>第一种：线程 2 先执行，然后线程 1 后执行，r1 的结果为 4<br>第二种：线程 1 先执行，然后线程 2 后执行，r1 的结果为 1<br>第三种：线程 2 先执行，但是发送了指令重排，num &#x3D; 2 与 ready &#x3D; true 这两行代码语序发生装换，然后执行 ready &#x3D; true 后，线程 1 运行了，那么 r1 的结果是为 0。</p>
<p>这种现象叫做指令重排，是 JIT 编译器在运行时的一些优化，这个现象需要通过大量测试才能复现： 借助 java 并发压测工具 jcstress <a target="_blank" rel="noopener" href="https://wiki.openjdk.java.net/display/CodeTools/jcstress">https://wiki.openjdk.java.net/display/CodeTools/jcstress</a></p>
<p>指令重排的例子，double-checked locking 问题：</p>
<p>第一个if不加的话,每次调用这个方法都得加锁,加上if,只有在第一次调用该方法时需要加锁,等该对象的instance初始化后在调用该方法,直接return不加锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">	<span class="comment">// 最开始的单例模式是这样的</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123; &#125;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 首次访问会同步，而之后的使用不用进入synchronized</span></span><br><span class="line">        <span class="keyword">synchronized</span>(Singleton.class) &#123;</span><br><span class="line">        	<span class="keyword">if</span> (INSTANCE == <span class="literal">null</span>) &#123; <span class="comment">// t1</span></span><br><span class="line">        		INSTANCE = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">            <span class="keyword">return</span> INSTANCE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 但是上面的代码块的效率是有问题的，因为即使已经产生了单实例之后，之后调用了getInstance()方法之后还是会加锁，这会严重影响性能！因此就有了模式如下double-checked lockin：</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123; &#125;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(INSTANCE == <span class="literal">null</span>) &#123; <span class="comment">// t2</span></span><br><span class="line">                <span class="comment">// 首次访问会同步，而之后的使用没有 synchronized</span></span><br><span class="line">                <span class="keyword">synchronized</span>(Singleton.class) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (INSTANCE == <span class="literal">null</span>) &#123; <span class="comment">// t1</span></span><br><span class="line">                        INSTANCE = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> INSTANCE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//但是上面的if(INSTANCE == null)判断代码没有在同步代码块synchronized中，不能享有synchronized保证的原子性，可见性。所以</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>正常是先调用构造方法再赋值引用，调过来的话多线程就会出现没有构造完成的对象被使用，报错，调用构造方法比较耗时</p>
<hr>
<h1 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h1><p>CAS 即 Compare and Swap ，它体现的一种乐观锁的思想，比如多个线程要对一个共享的整型变量执 行 +1 操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line"><span class="type">int</span> 旧值 = 共享变量 ; <span class="comment">// 比如拿到了当前值 0</span></span><br><span class="line"><span class="type">int</span> 结果 = 旧值 + <span class="number">1</span>; <span class="comment">// 在旧值 0 的基础上增加 1 ，正确结果是 1</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这时候如果别的线程把共享变量改成了 5，本线程的正确结果 1 就作废了，这时候</span></span><br><span class="line"><span class="comment">compareAndSwap 返回 false，重新尝试，直到：</span></span><br><span class="line"><span class="comment">compareAndSwap 返回 true，表示我本线程做修改的同时，别的线程没有干扰</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">if</span>( compareAndSwap ( 旧值, 结果 )) &#123;</span><br><span class="line"><span class="comment">// 成功，退出循环</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>compareAndSwap</code>，是根据地址再取一次旧值（新旧值）,然后与旧值（旧旧值）比较，如果一样就set（内部保证原子性）结果，不一样就再试。</p>
<p>获取共享变量时，为了保证该变量的可见性，需要使用 volatile 修饰。结合 CAS 和 volatile 可以实现无 锁并发，适用于竞争不激烈、多核 CPU 的场景下。 </p>
<ul>
<li>因为没有使用 synchronized，所以线程不会陷入阻塞，这是效率提升的因素之一 </li>
<li>但如果竞争激烈，可以想到重试必然频繁发生，反而效率会受影响</li>
</ul>
<p>CAS 底层依赖于一个 Unsafe 类来直接调用操作系统底层的 CAS 指令。 </p>
<h2 id="乐观锁和悲观锁"><a href="#乐观锁和悲观锁" class="headerlink" title="乐观锁和悲观锁"></a>乐观锁和悲观锁</h2><p><strong>CAS</strong> 是基于乐观锁的思想：最乐观的估计，不怕别的线程来修改共享变量，就算改了也没关系， 我吃亏点再重试呗。 </p>
<p><strong>synchronized</strong> 是基于悲观锁的思想：最悲观的估计，得防着其它线程来修改共享变量，我上了锁 你们都别想改，我改完了解开锁，你们才有机会。</p>
<h2 id="原子操作类"><a href="#原子操作类" class="headerlink" title="原子操作类"></a>原子操作类</h2><p><code>java.util.concurrent.atomic</code>并发包提供了一些并发工具类，可以提供线程安全的操作，他们底层就是采用CAS技术+volatile实现的，这里把它分成五类：<br>使用原子的方式更新基本类型</p>
<ul>
<li>AtomicInteger：整型原子类</li>
<li>AtomicLong：长整型原子类</li>
<li>AtomicBoolean ：布尔型原子类</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/09/21/synchronized/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="LLCH Liu">
      <meta itemprop="description" content="Here we go!!!!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Here We Go">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/09/21/synchronized/" class="post-title-link" itemprop="url">synchronized</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-09-21 15:52:56" itemprop="dateCreated datePublished" datetime="2023-09-21T15:52:56+08:00">2023-09-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-09-27 22:33:45" itemprop="dateModified" datetime="2023-09-27T22:33:45+08:00">2023-09-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JVM/" itemprop="url" rel="index"><span itemprop="name">-JVM</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ul>
<li><p>synchronized关键字解决的是多个线程之间访问资源的同步性，synchronized 翻译为中文的意思是同步，也称之为”同步锁“。</p>
</li>
<li><p>synchronized的作用是保证在同一时刻， 被修饰的代码块或方法只会有一个线程执行，以达到保证并发安全的效果。</p>
</li>
<li><p>synchronized具体来说，当一个线程获取到锁时，它会把当前线程的本地内存中的共享变量值与主内存中的共享变量值进行比较，如果不一致，则使用本地内存中的共享变量值更新主内存中的共享变量值。</p>
</li>
<li><p>synchronized保证可见性，原子性，有序性</p>
</li>
<li><p>synchronized获取锁会从主存刷新值，释放锁也会将修改的值刷新到主存，保证了可见性</p>
</li>
<li><p>因为println加了synchronized，synchronized会先清理缓存再读</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">Code:</span><br><span class="line">     stack=2, locals=5, args_size=1</span><br><span class="line">        0: bipush        10</span><br><span class="line">        2: istore_1</span><br><span class="line">        3: new           #2                  // class java/lang/Object</span><br><span class="line">        6: dup</span><br><span class="line">        7: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">       10: astore_2</span><br><span class="line">       11: aload_2</span><br><span class="line">       12: dup</span><br><span class="line">       13: astore_3</span><br><span class="line">       14: monitorenter //加锁</span><br><span class="line">       15: getstatic     #3                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">       18: iload_1</span><br><span class="line">       19: invokevirtual #4                  // Method java/io/PrintStream.println:(I)V</span><br><span class="line">      astore_3</span><br><span class="line">       23: monitorexit //解锁</span><br><span class="line">       24: goto          34</span><br><span class="line">       //异常操作</span><br><span class="line">       27: astore        4</span><br><span class="line">       29: aload_3</span><br><span class="line">       30: monitorexit //解锁</span><br><span class="line">       31: aload         4</span><br><span class="line">       33: athrow</span><br><span class="line">       34: return</span><br><span class="line">     Exception table:</span><br><span class="line">        from    to  target type</span><br><span class="line">           15    24    27   any</span><br><span class="line">           27    31    27   any</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p> <code>3: new</code>  放进操作输入栈然后<code>dup</code>，把对象lock复制了一份，为了使用两次。第一次，消耗栈顶引用，用 <code>7: invokespecial</code> 调用构造方法；10: astore_2&#96;是把第二个赋值给2号槽位的lock。这部分是</p>
<p><code>Object lock = new Object()</code>的解读</p>
<p>接下来是syn的方法了，首先<code>11: aload_2</code>将对象加入操作出栈表示syn开始，接下来 <code>dup</code>复制lock引用，一个给<code>monitorenter</code>，一个给<code>monitorexit</code>，分别对应加锁指令和解锁指令。</p>
<p> <code>astore_3</code>先把lock引用存储到3号槽位，栈顶还剩下一个lock引用，此引用配合<code>monitorenter</code>把lock引用消耗，对lock引用指向的对象进行了一个加锁的操作，然后执行打印操作<code>system.out.println</code>15~19。</p>
<p>如果没有异常 <code>astore_3</code>把lcok引用加载到栈顶再执行<code>23: monitorexit</code>对同一个对象执行解锁，然后goto 34结束。</p>
<p>如果出现异常查看异常表<code>Exception table</code>，如果from 15 to 24 出现异常进入27（from27 to 31同理） ，<code>astore</code>存储异常，  <code>astore_3</code>把lcok引用加载到栈顶再执行<code>23: monitorexit</code>对同一个对象执行解锁，<code>aload</code>加载出之前存在4号槽位的异常，<code>athrow</code>抛出，最后结束。</p>
<h1 id="synchronized优化"><a href="#synchronized优化" class="headerlink" title="synchronized优化"></a>synchronized优化</h1><p>Java HotSpot 虚拟机中，每个对象都有对象头（包括 class 指针和 Mark Word）一共八个字节。Mark Word 平时存 储这个对象的 <code>哈希码</code> 、 <code>分代年龄</code> ，当加锁时，这些信息就根据情况被替换为 <code>标记位</code> 、 <code>线程锁记录指 针</code> 、 <code>重量级锁指针</code> 、 <code>线程ID</code> 等内容</p>
<p><strong>标记位</strong>就是标记为添加的是轻量级锁，重量级锁，还是偏向锁。</p>
<h2 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h2><p>如果一个对象虽然有多线程访问，需要synchronized保护，但多线程访问的时间是错开的（也就是没有竞争），那么可以使用轻 量级锁来优化。</p>
<p>好比：学生（线程 A）用课本占座，上了半节课，出门了（CPU时间到），回来一看，发现课本没变，说明没 有竞争，继续上他的课。 如果这期间有其它学生（线程 B）来了，会告知（线程A）有并发访问，线程 A 随即升级为重量级锁， 进入重量级锁的流程（此升级过程为<strong>锁膨胀</strong>）。 而重量级锁就不是那么用课本占座那么简单了，可以想象线程 A 走之前，把座位用一个铁栅栏围起来</p>
<p>每个线程都的栈帧都会包含一个锁记录的结构，内部可以存储锁定对象的 Mark Word。将来解锁的时候，暂存的MarkWord的信息返回去。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">static Object obj = new Object();</span><br><span class="line">public static void method1() &#123;</span><br><span class="line">synchronized( obj ) &#123;</span><br><span class="line">// 同步块 A</span><br><span class="line">method2();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public static void method2() &#123;</span><br><span class="line">synchronized( obj ) &#123;</span><br><span class="line">// 同步块 B</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li><strong>25</strong></li>
</ul>
<p><img src="/../filename/25.png">  </p>
<h1 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h1><p>重量级锁竞争的时候，还可以使用自旋来进行优化，如果当前线程自旋成功（即这时候持锁线程已经退 出了同步块，释放了锁），这时当前线程就可以避免阻塞。 在 Java 6 之后自旋锁是自适应的，比如对象刚刚的一次自旋操作成功过，那么认为这次自旋成功的可能 性会高，就多自旋几次；反之，就少自旋甚至不自旋，总之，比较智能。</p>
<ul>
<li>自旋会占用 CPU 时间，单核 CPU 自旋就是浪费，多核 CPU 自旋才能发挥优势。</li>
<li>好比等红灯时汽车是不是熄火，不熄火相当于自旋（等待时间短了划算），熄火了相当于阻塞（等 待时间长了划算）</li>
<li>Java 7 之后不能控制是否开启自旋功能</li>
</ul>
<p>自旋多次后，不能加锁就进入阻塞状态</p>
<h2 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h2><p>轻量级锁在没有竞争时（就自己这个线程），每次重入仍然需要执行 CAS 操作。Java 6 中引入了偏向锁 来做进一步优化：只有第一次使用 CAS 将线程 ID 设置到对象的 Mark Word 头，之后<strong>发现这个线程 ID 是自己的就表示没有竞争，不用重新 CAS.</strong> </p>
<ul>
<li><strong>撤销偏向锁</strong>需要将持锁线程升级为轻量级锁，这个过程中所有线程需要暂停（<strong>STW</strong>） </li>
<li>访问对象的 hashCode 也会撤销偏向锁 </li>
<li>如果对象虽然被多个线程访问，但没有竞争，这时偏向了线程 T1 的对象仍有机会重新偏向 T2， 重偏向会重置对象的 Thread ID </li>
<li>撤销偏向和重偏向都是批量进行的，以类为单位 </li>
<li>如果撤销偏向到达某个<strong>阈值</strong>，整个类的所有对象都会变为不可偏向的 </li>
<li>可以主动使用 <code>-XX:-UseBiasedLocking</code> 禁用偏向锁</li>
</ul>
<h2 id="其他优化"><a href="#其他优化" class="headerlink" title="其他优化"></a>其他优化</h2><ol>
<li><p><strong>减少上锁时间</strong> </p>
<p>同步代码块中尽量短。上锁时间段，竞争机会少。不要把一大堆代码都用synchronized关键字包起来。</p>
</li>
<li><p><strong>减少锁的力度</strong></p>
<p>一个锁拆成多个锁是可以提高并发度的：</p>
<ul>
<li><p>ConcurrentHashMap。相当于把数组的链表头上加锁，锁住了整个hashtable，读写操作是完全互斥的，如果锁住链表头相当于加锁的力度变小，每次都是锁住一个链表，其他链表的读写操作不受影响</p>
</li>
<li><p>LongAdder 分为 base 和 cells 两部分。没有并发争用的时候或者是 cells 数组正在初始化的时 候，会使用 CAS 来累加值到 base，有并发争用，会初始化 cells 数组，数组有多少个 cell，就允 许有多少线程并行修改，最后将数组中每个 cell 累加，再加上 base 就是最终的值</p>
</li>
<li><p>LinkedBlockingQueue 入队和出队使用不同的锁，相对于LinkedBlockingArray只有一个锁效率要 高</p>
</li>
</ul>
<p><strong>3.锁的粗化</strong></p>
<p>多次循环进入同步块不如同步块内多次循环 </p>
<p>另外 JVM 可能会做如下优化，把多次 append 的加锁操作粗化为一次（因为都是对同一个对象加锁， 没必要重入多次）</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">StringBuffer</span>().append(<span class="string">&quot;a&quot;</span>).append(<span class="string">&quot;b&quot;</span>).append(<span class="string">&quot;c&quot;</span>);</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><p><strong>锁消除 JVM</strong> </p>
<p>会进行代码的<strong>逃逸分析</strong>，例如某个加锁对象是方法内局部变量，不会被其它线程所访问到，这时候 就会被即时编译器忽略掉所有同步操作。比如说上面的stringbuffer没被其他线程访问到，机会吧string buffer的synchronized消除掉</p>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/09/21/G1%E9%87%8D%E7%82%B9%E6%8F%8F%E8%BF%B0%E4%B8%80%E9%81%8D/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="LLCH Liu">
      <meta itemprop="description" content="Here we go!!!!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Here We Go">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/09/21/G1%E9%87%8D%E7%82%B9%E6%8F%8F%E8%BF%B0%E4%B8%80%E9%81%8D/" class="post-title-link" itemprop="url">G1重点描述一遍</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-09-21 10:25:06 / 修改时间：10:29:20" itemprop="dateCreated datePublished" datetime="2023-09-21T10:25:06+08:00">2023-09-21</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>背景</p>
<p>在G1出现之前，包括在cms出现之前</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/09/19/ClassLoading/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="LLCH Liu">
      <meta itemprop="description" content="Here we go!!!!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Here We Go">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/09/19/ClassLoading/" class="post-title-link" itemprop="url">类加载和字节码技术</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-09-19 23:52:06" itemprop="dateCreated datePublished" datetime="2023-09-19T23:52:06+08:00">2023-09-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-09-26 17:06:17" itemprop="dateModified" datetime="2023-09-26T17:06:17+08:00">2023-09-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JVM/" itemprop="url" rel="index"><span itemprop="name">-JVM</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><img src="/filename/11.png"></p>
<h1 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a>类加载</h1><p>执行 <code>javac -parameters -d . HellowWorld.java</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HelloWorld 示例</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorld</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译为 <code>HelloWorld.class</code> 得到的<strong>字节码文件</strong>是这个样子的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">0000000 ca fe ba be 00 00 00 34 00 23 0a 00 06 00 15 09 </span><br><span class="line">0000020 00 16 00 17 08 00 18 0a 00 19 00 1a 07 00 1b 07 </span><br><span class="line">0000040 00 1c 01 00 06 3c 69 6e 69 74 3e 01 00 03 28 29 </span><br><span class="line">0000060 56 01 00 04 43 6f 64 65 01 00 0f 4c 69 6e 65 4e </span><br><span class="line">0000100 75 6d 62 65 72 54 61 62 6c 65 01 00 12 4c 6f 63 </span><br><span class="line">0000120 61 6c 56 61 72 69 61 62 6c 65 54 61 62 6c 65 01 </span><br><span class="line">0000140 00 04 74 68 69 73 01 00 1d 4c 63 6e 2f 69 74 63 </span><br><span class="line">0000160 61 73 74 2f 6a 76 6d 2f 74 35 2f 48 65 6c 6c 6f </span><br><span class="line">0000200 57 6f 72 6c 64 3b 01 00 04 6d 61 69 6e 01 00 16 </span><br><span class="line">0000220 28 5b 4c 6a 61 76 61 2f 6c 61 6e 67 2f 53 74 72 </span><br><span class="line">0000240 69 6e 67 3b 29 56 01 00 04 61 72 67 73 01 00 13 </span><br><span class="line">0000260 5b 4c 6a 61 76 61 2f 6c 61 6e 67 2f 53 74 72 69 </span><br><span class="line">0000300 6e 67 3b 01 00 10 4d 65 74 68 6f 64 50 61 72 61 </span><br><span class="line">0000320 6d 65 74 65 72 73 01 00 0a 53 6f 75 72 63 65 46 </span><br><span class="line">0000340 69 6c 65 01 00 0f 48 65 6c 6c 6f 57 6f 72 6c 64</span><br><span class="line">0000360 2e 6a 61 76 61 0c 00 07 00 08 07 00 1d 0c 00 1e </span><br><span class="line">0000400 00 1f 01 00 0b 68 65 6c 6c 6f 20 77 6f 72 6c 64 </span><br><span class="line">0000420 07 00 20 0c 00 21 00 22 01 00 1b 63 6e 2f 69 74 </span><br><span class="line">0000440 63 61 73 74 2f 6a 76 6d 2f 74 35 2f 48 65 6c 6c </span><br><span class="line">0000460 6f 57 6f 72 6c 64 01 00 10 6a 61 76 61 2f 6c 61 </span><br><span class="line">0000500 6e 67 2f 4f 62 6a 65 63 74 01 00 10 6a 61 76 61 </span><br><span class="line">0000520 2f 6c 61 6e 67 2f 53 79 73 74 65 6d 01 00 03 6f </span><br><span class="line">0000540 75 74 01 00 15 4c 6a 61 76 61 2f 69 6f 2f 50 72 </span><br><span class="line">0000560 69 6e 74 53 74 72 65 61 6d 3b 01 00 13 6a 61 76 </span><br><span class="line">0000600 61 2f 69 6f 2f 50 72 69 6e 74 53 74 72 65 61 6d </span><br><span class="line">0000620 01 00 07 70 72 69 6e 74 6c 6e 01 00 15 28 4c 6a </span><br><span class="line">0000640 61 76 61 2f 6c 61 6e 67 2f 53 74 72 69 6e 67 3b </span><br><span class="line">0000660 29 56 00 21 00 05 00 06 00 00 00 00 00 02 00 01 </span><br><span class="line">0000700 00 07 00 08 00 01 00 09 00 00 00 2f 00 01 00 01 </span><br><span class="line">0000720 00 00 00 05 2a b7 00 01 b1 00 00 00 02 00 0a 00 </span><br><span class="line">0000740 00 00 06 00 01 00 00 00 04 00 0b 00 00 00 0c 00 </span><br><span class="line">0000760 01 00 00 00 05 00 0c 00 0d 00 00 00 09 00 0e 00 </span><br><span class="line">0001000 0f 00 02 00 09 00 00 00 37 00 02 00 01 00 00 00 </span><br><span class="line">0001020 09 b2 00 02 12 03 b6 00 04 b1 00 00 00 02 00 0a </span><br><span class="line">0001040 00 00 00 0a 00 02 00 00 00 06 00 08 00 07 00 0b </span><br><span class="line">0001060 00 00 00 0c 00 01 00 00 00 09 00 10 00 11 00 00 </span><br><span class="line">0001100 00 12 00 00 00 05 01 00 10 00 00 00 01 00 13 00 </span><br><span class="line">0001120 00 00 02 00 14</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>根据 JVM 规范，类文件结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">u4 			   magic</span><br><span class="line">u2             minor_version;    </span><br><span class="line">u2             major_version;    </span><br><span class="line">u2             constant_pool_count;    </span><br><span class="line">cp_info        constant_pool[constant_pool_count-1];    </span><br><span class="line">u2             access_flags;    </span><br><span class="line">u2             this_class;    </span><br><span class="line">u2             super_class;   </span><br><span class="line">u2             interfaces_count;    </span><br><span class="line">u2             interfaces[interfaces_count];   </span><br><span class="line">u2             fields_count;    </span><br><span class="line">field_info     fields[fields_count];   </span><br><span class="line">u2             methods_count;    </span><br><span class="line">method_info    methods[methods_count];    </span><br><span class="line">u2             attributes_count;    </span><br><span class="line">attribute_info attributes[attributes_count];</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>魔数</strong><br>对应字节码文件 0~3 字节，表示它是否是【class】类型的文件</p>
<p>0000000 <strong>ca fe ba be</strong> 00 00 00 34 00 23 0a 00 06 00 15 09</p>
<p><strong>版本</strong><br>对应字节码文件 4~7 字节，表示类的版本 00 34（52） 表示是 Java 8</p>
<p>0000000 ca fe ba be <strong>00 00 00 34</strong> 00 23 0a 00 06 00 15 09</p>
<p><strong>常量池</strong></p>
<p><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5">参考官方文档</a></p>
<hr>
<h1 id="字节码指令"><a href="#字节码指令" class="headerlink" title="字节码指令"></a>字节码指令</h1><h2 id="javap工具"><a href="#javap工具" class="headerlink" title="javap工具"></a>javap工具</h2><p><code>javap -v 类名.class</code>来反编译class文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\30287\IdeaProjects\paiXppLL\src\main&gt;javap -v Main.class</span><br><span class="line">Classfile /C:/Users/30287/IdeaProjects/paiXppLL/src/main/Main.class</span><br><span class="line">  Last modified 2021-10-14; size 419 bytes</span><br><span class="line">  MD5 checksum eda2e7897356a975438fe5899c0b4a6c</span><br><span class="line">  Compiled from &quot;Main.java&quot;</span><br><span class="line">public class main.Main</span><br><span class="line">  minor version: 0</span><br><span class="line">  major version: 52</span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line">   #1 = Methodref          #6.#15         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">   #2 = Fieldref           #16.#17        // java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">   #3 = String             #18            // hello world!</span><br><span class="line">   #4 = Methodref          #19.#20        // java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">   #5 = Class              #21            // main/Main</span><br><span class="line">   #6 = Class              #22            // java/lang/Object</span><br><span class="line">   #7 = Utf8               &lt;init&gt;</span><br><span class="line">   #8 = Utf8               ()V</span><br><span class="line">   #9 = Utf8               Code</span><br><span class="line">  #10 = Utf8               LineNumberTable</span><br><span class="line">  #11 = Utf8               main</span><br><span class="line">  #12 = Utf8               ([Ljava/lang/String;)V</span><br><span class="line">  #13 = Utf8               SourceFile</span><br><span class="line">  #14 = Utf8               Main.java</span><br><span class="line">  #15 = NameAndType        #7:#8          // &quot;&lt;init&gt;&quot;:()V</span><br><span class="line">  #16 = Class              #23            // java/lang/System</span><br><span class="line">  #17 = NameAndType        #24:#25        // out:Ljava/io/PrintStream;</span><br><span class="line">  #18 = Utf8               hello world!</span><br><span class="line">  #19 = Class              #26            // java/io/PrintStream</span><br><span class="line">  #20 = NameAndType        #27:#28        // println:(Ljava/lang/String;)V</span><br><span class="line">  #21 = Utf8               main/Main</span><br><span class="line">  #22 = Utf8               java/lang/Object</span><br><span class="line">  #23 = Utf8               java/lang/System</span><br><span class="line">  #24 = Utf8               out</span><br><span class="line">  #25 = Utf8               Ljava/io/PrintStream;</span><br><span class="line">  #26 = Utf8               java/io/PrintStream</span><br><span class="line">  #27 = Utf8               println</span><br><span class="line">  #28 = Utf8               (Ljava/lang/String;)V</span><br><span class="line">&#123;</span><br><span class="line">  public main.Main();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=1, locals=1, args_size=1</span><br><span class="line">         0: aload_0</span><br><span class="line">         1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">         4: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 13: 0</span><br><span class="line"></span><br><span class="line">  public static void main(java.lang.String[]);</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=2, locals=1, args_size=1</span><br><span class="line">         0: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">         3: ldc           #3                  // String hello world!</span><br><span class="line">         5: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">         8: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 15: 0</span><br><span class="line">        line 16: 8</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>2~4本身自己信息</p>
<p>5：全路径名称</p>
<p> <code>flags: ACC_PUBLIC, ACC_SUPER</code>：类的修饰符，public的类</p>
<p><code>Constant pool</code>：常量池</p>
<p><code>Methodref</code>：成员引用</p>
<p><code>invokespecial</code>：调用方法</p>
<h2 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 演示 字节码指令 和 操作数栈、常量池的关系</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo3_1</span> &#123;   </span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        </span><br><span class="line">		<span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;        </span><br><span class="line">		<span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> Short.MAX_VALUE + <span class="number">1</span>;        </span><br><span class="line">		<span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> a + b;        </span><br><span class="line">		System.out.println(c);   </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# javap -v Demo3_1.class</span><br><span class="line">Classfile /root/Demo3_1.class</span><br><span class="line">Last modified Jul 7, 2019; size 665 bytes</span><br><span class="line">MD5 checksum a2c29a22421e218d4924d31e6990cfc5</span><br><span class="line">Compiled from &quot;Demo3_1.java&quot;</span><br><span class="line">public class cn.itcast.jvm.t3.bytecode.Demo3_1</span><br><span class="line">minor version: 0</span><br><span class="line">major version: 52</span><br><span class="line">flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line">#1 = Methodref #7.#26 // java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">#2 = Class #27 // java/lang/Short</span><br><span class="line">#3 = Integer 32768</span><br><span class="line">#4 = Fieldref #28.#29 //</span><br><span class="line">java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">#5 = Methodref #30.#31 // java/io/PrintStream.println:(I)V</span><br><span class="line">#6 = Class #32 // cn/itcast/jvm/t3/bytecode/Demo3_1</span><br><span class="line">#7 = Class #33 // java/lang/Object</span><br><span class="line">#8 = Utf8 &lt;init&gt;</span><br><span class="line">#9 = Utf8 ()V</span><br><span class="line">#10 = Utf8 Code</span><br><span class="line">#11 = Utf8 LineNumberTable</span><br><span class="line">#12 = Utf8 LocalVariableTable</span><br><span class="line">#13 = Utf8 this</span><br><span class="line">#14 = Utf8 Lcn/itcast/jvm/t3/bytecode/Demo3_1;</span><br><span class="line">#15 = Utf8 main</span><br><span class="line">#16 = Utf8 ([Ljava/lang/String;)V</span><br><span class="line">#17 = Utf8 args</span><br><span class="line">#18 = Utf8 [Ljava/lang/String;</span><br><span class="line">#19 = Utf8 a</span><br><span class="line">#22 = Utf8 c</span><br><span class="line">#23 = Utf8 MethodParameters</span><br><span class="line">#24 = Utf8 SourceFile</span><br><span class="line">#25 = Utf8 Demo3_1.java</span><br><span class="line">#26 = NameAndType #8:#9 // &quot;&lt;init&gt;&quot;:()V</span><br><span class="line">#27 = Utf8 java/lang/Short</span><br><span class="line">#28 = Class #34 // java/lang/System</span><br><span class="line">#29 = NameAndType #35:#36 // out:Ljava/io/PrintStream;</span><br><span class="line">#30 = Class #37 // java/io/PrintStream</span><br><span class="line">#31 = NameAndType #38:#39 // println:(I)V</span><br><span class="line">#32 = Utf8 cn/itcast/jvm/t3/bytecode/Demo3_1</span><br><span class="line">#33 = Utf8 java/lang/Object</span><br><span class="line">#34 = Utf8 java/lang/System</span><br><span class="line">#35 = Utf8 out</span><br><span class="line">#36 = Utf8 Ljava/io/PrintStream;</span><br><span class="line">#37 = Utf8 java/io/PrintStream</span><br><span class="line">#38 = Utf8 println</span><br><span class="line">#39 = Utf8 (I)V</span><br><span class="line">&#123;</span><br><span class="line">public cn.itcast.jvm.t3.bytecode.Demo3_1();</span><br><span class="line">descriptor: ()V</span><br><span class="line">flags: ACC_PUBLIC</span><br><span class="line">Code:</span><br><span class="line">stack=1, locals=1, args_size=1</span><br><span class="line">0: aload_0</span><br><span class="line">1: invokespecial #1 // Method java/lang/Object.&quot;</span><br><span class="line">&lt;init&gt;&quot;:()V</span><br><span class="line">4: return</span><br><span class="line">LineNumberTable:</span><br><span class="line">line 6: 0</span><br><span class="line">LocalVariableTable:</span><br><span class="line">Start Length Slot Name Signature</span><br><span class="line">0 5 0 this Lcn/itcast/jvm/t3/bytecode/Demo3_1;</span><br><span class="line">public static void main(java.lang.String[]);</span><br><span class="line">descriptor: ([Ljava/lang/String;)V</span><br><span class="line">flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">Code:</span><br><span class="line">stack=2, locals=4, args_size=1</span><br><span class="line">0: bipush 10</span><br><span class="line">2: istore_1</span><br><span class="line">3: ldc #3 // int 32768</span><br><span class="line">5: istore_2</span><br><span class="line">6: iload_1</span><br><span class="line">7: iload_2</span><br><span class="line">8: iadd</span><br><span class="line">9: istore_3</span><br><span class="line">10: getstatic #4 // Field</span><br><span class="line">java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">13: iload_3</span><br><span class="line">14: invokevirtual #5 // Method</span><br><span class="line">java/io/PrintStream.println:(I)V</span><br><span class="line">17: return</span><br><span class="line">LineNumberTable:</span><br><span class="line">line 8: 0</span><br><span class="line">line 9: 3</span><br><span class="line">line 12: 17</span><br><span class="line">LocalVariableTable:</span><br><span class="line">Start Length Slot Name Signature</span><br><span class="line">0 18 0 args [Ljava/lang/String;</span><br><span class="line">3 15 1 a I</span><br><span class="line">6 12 2 b I</span><br><span class="line">10 8 3 c I</span><br><span class="line">MethodParameters:</span><br><span class="line">Name Flags</span><br><span class="line">args</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>常量池载入运行时常量池</strong></p>
<p><img src="/filename/12.png"></p>
<p><strong>字节方法码载入方法区</strong></p>
<p>![](filename&#x2F;13 .png)</p>
<p><strong>main线程开始运行，分配栈帧内存</strong></p>
<p><img src="/filename/14.png"></p>
<p><strong>执行引擎开始执行字节码</strong></p>
<p><strong>bipush10</strong>：</p>
<ul>
<li>将一个 byte 压入操作数栈（其长度会补齐 4 个字节），类似的指令还有</li>
<li>sipush 将一个 short 压入操作数栈（其长度会补齐 4 个字节）</li>
<li>ldc 将一个 int 压入操作数栈</li>
<li>ldc2_w 将一个 long 压入操作数栈（分两次压入，因为 long 是 8 个字节）</li>
<li>这里小的数字都是和字节码指令存在一起，超过 short 范围的数字存入了常量池</li>
</ul>
<p><strong>istore 1</strong>：</p>
<ul>
<li>将操作数栈栈顶元素弹出，放入局部变量表的slot 1中</li>
</ul>
<p><img src="/filename/15.png"></p>
<p><strong>ldc #3</strong>：</p>
<ul>
<li>从常量池加载 #3 数据到操作数栈</li>
<li>注意 <code>Short.MAX_VALUE</code> 是 32767，所以 32768 &#x3D; Short.MAX_VALUE + 1 实际是在编译期间计算好的</li>
</ul>
<p><img src="/filename/20.png"></p>
<p><strong>istore_2</strong>：</p>
<p>将操作数栈中的元素弹出，放到局部变量表的2号位置</p>
<p><img src="/filename/16.png"></p>
<p><strong>iload1</strong>：</p>
<p>将局部变量表中1号位置的元素放入操作数栈中</p>
<p><strong>iload2</strong>：</p>
<p>将局部变量表中2号位置的元素放入操作数栈中</p>
<p><strong>iadd</strong>：</p>
<p>将操作数栈中的两个元素弹出栈并相加，结果在压入操作数栈中</p>
<p><strong>istore 3</strong>：</p>
<p>将操作数栈中的元素弹出，放入局部变量表的3号位置</p>
<p><strong>getstatic #4</strong>：</p>
<p>在运行时常量池中找到#4，发现是一个对象</p>
<p>在堆内存中找到该对象，并将其<strong>引用</strong>放入操作数栈中</p>
<p><strong>iload 3</strong>：</p>
<p><strong>invokevirtual 5</strong>：</p>
<ul>
<li>找到常量池 #5 项</li>
<li>定位到方法区 <code>java/io/PrintStream.println:(I)V</code> 方法</li>
<li>生成新的栈帧（分配 locals、stack等）</li>
<li>传递参数，执行新栈帧中的字节码</li>
<li>执行完毕，弹出栈帧</li>
<li>清除 main 操作数栈内容</li>
</ul>
<p><strong>return</strong>：</p>
<ul>
<li>完成 main 方法调用，弹出 main 栈帧</li>
<li>程序结束</li>
</ul>
<hr>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Main</span> <span class="variable">m</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Main</span>();</span><br><span class="line">        m.test1();</span><br><span class="line">        m.test2();</span><br><span class="line">        m.test3();</span><br><span class="line">        Main.test4();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>不同方法在调用时，对应的虚拟机指令有所区别：</p>
<ul>
<li><p><code>invokeSpecial</code>和<code>invokeStatic</code>属于<strong>静态绑定</strong></p>
</li>
<li><p>私有、构造、被final修饰的方法，在调用时都使用<code>invokespecial</code>指令</p>
</li>
<li><p>普通成员方法在调用时，使用i<code>nvokevirtual</code>指令。因为<strong>编译期间无法确定该方法的内容</strong>，只有在运行期间才能确定，属于<strong>动态绑定</strong>，即支持多态</p>
</li>
<li><p>静态方法在调用时使用**<code>invokestatic</code>**指令</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Code:</span><br><span class="line">     stack=2, locals=2, args_size=1</span><br><span class="line">        0: new           #2                  // class main/Main</span><br><span class="line">        3: dup</span><br><span class="line">        4: invokespecial #3                  // Method &quot;&lt;init&gt;&quot;:()V</span><br><span class="line">        7: astore_1</span><br><span class="line">        8: aload_1</span><br><span class="line">        9: invokespecial #4                  // Method test1:()V</span><br><span class="line">       12: aload_1</span><br><span class="line">       13: invokespecial #5                  // Method test2:()V</span><br><span class="line">       16: aload_1</span><br><span class="line">       17: invokevirtual #6                  // Method test3:()V</span><br><span class="line">       20: invokestatic  #7                  // Method test4:()V</span><br><span class="line">       23: return</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<ul>
<li>new 是创建【对象】，给对象分配堆内存，执行成功会将【对象引用】压入操作数栈</li>
<li>dup 是<strong>复制</strong>操作数栈栈顶的内容，本例即为【对象引用】，为什么需要两份引用呢，一个是要配合 <code>invokespecial</code> 调用该对象的构造方法 （会消耗掉栈顶一个引用），另一个要配合 <code>astore_1</code> 赋值给局部变量</li>
<li>成员方法与静态方法调用的另一个区别是，执行方法前是否需要【对象引用】</li>
</ul>
<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><ul>
<li><p>运行jps，获取进程Id</p>
</li>
<li><p>运行Hsdb工具，可以看到比较底层的原理</p>
</li>
<li><p>进入JDK安装目录，执行**<code>java -cp .lib/sa-jdi.jar sun.jvm.hotspot.HSDB</code>**，进入图形界面</p>
<p>Attach id</p>
</li>
</ul>
<hr>
<p> <strong>vtable</strong>:多态的方法存在在一张加vtable的虚方法表中，静态，final，私有不会在内</p>
<p><strong>从JVM内部角度看，java多态的实现是通过itable（interface method table：接口方法表）, vtable（virtual method table：虚函数表）来实现方法的准确跳转。</strong></p>
<ul>
<li>先通过栈帧中对象的引用找到对象</li>
<li>分析对象头，找到对象实际的Class</li>
<li>Class结构中有<strong>vtable</strong>，它在类加载的链接阶段就已经根据方法的重写规则生成好了</li>
<li>查询<strong>vtable</strong>找到方法的具体地址</li>
<li>执行方法的字节码</li>
</ul>
<hr>
<p>异常catch</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            i = <span class="number">10</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            i = <span class="number">20</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>重点，省略了部分</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Code:</span><br><span class="line">    stack=1, locals=3, args_size=1</span><br><span class="line">       0: iconst_0</span><br><span class="line">       1: istore_1</span><br><span class="line">       2: bipush        10</span><br><span class="line">       4: istore_1</span><br><span class="line">       5: goto          12</span><br><span class="line">       8: astore_2</span><br><span class="line">       9: bipush        20</span><br><span class="line">      11: istore_1</span><br><span class="line">      12: return</span><br><span class="line">    Exception table:</span><br><span class="line">       from    to  target type</span><br><span class="line">           2     5     8   Class java/lang/Exception</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><p>可以看到多出来一个 Exception table 的结构，[from, to) 是前闭后开（也就是检测2~4行）的检测范围，一旦这个范围内的字节码执行出现异常，先进行类型匹配，是否一致，如果一致，进入 target 所指示行号。</p>
</li>
<li><p>8行的字节码指令 astore_2 是将异常对象引用存入局部变量表的2号位置（为e）。 </p>
</li>
<li><p>因为异常出现时，<strong>只能进入</strong> Exception table 中<strong>一个分支</strong>，所以局部变量表 slot 2 位置<strong>被共用</strong>，异常都放在一个槽位，没有必要创建多个槽位的信息。</p>
</li>
</ul>
<ul>
<li><p>finally的原理是将finally{}块中的代码分别放在try{…}的最后和catch{…}的最后</p>
</li>
<li><p>如果try除了问题,直接进入catch中,然后catch后面复制的finally就会被执行</p>
</li>
<li><p>如果没有出问题,try{}后面的代码就会被执行</p>
</li>
<li><p>todo 如果出现catch的异常类不匹配,程序就不会往下走了,此时的finally也不会被执行</p>
</li>
</ul>
<ul>
<li>因为检测的那段代码出现异常的时候肯定是在插入的finally前，所以不管有无异常，都只会执行一次finally块代码</li>
</ul>
<hr>
<ul>
<li>在返回数据时，先把返回结果暂存，等finally中内容执行完了再把暂存结果返回</li>
<li>由于 ﬁnally 中的 ireturn 被插入了所有可能的流程，因此返回结果肯定以ﬁnally的为准<br>如果在 ﬁnally 中出现了 return，会吞掉异常，所以不要在finally中进行返回操作</li>
</ul>
<h1 id="类加载阶段"><a href="#类加载阶段" class="headerlink" title="类加载阶段"></a>类加载阶段</h1><p>类加载阶段分为加载，连接接，初始化三阶段。<strong>加载和连接是可能交替运行的</strong>。</p>
<h2 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h2><p>java编译为字节码后，运行需要通过类加载器，把类的字节码加载到方法区中，内部采用C++的i<code>nstanceKlass</code>描述class类。insatance的重要fileld有：</p>
<blockquote>
<ul>
<li>_java_mirror 即 java 的类镜像，例如对 String 来说，它的镜像类就是 String.class，作用是把 klass 暴露给 java 使用</li>
<li>_super 即父类</li>
<li>_ﬁelds 即成员变量</li>
<li>_methods 即方法</li>
<li>_constants 即常量池</li>
<li>_class_loader 即类加载器</li>
<li>_vtable 虚方法表</li>
<li>_itable 接口方法</li>
</ul>
</blockquote>
<p>java类访问Klass对象不能直接访问，要通过<code>_java_mirror</code>，这个javaMirror相当于Java和c++的桥梁。<code>xxx.class</code>就是instanceKlass的镜像。</p>
<p><img src="/../filename/17.png"></p>
<p>类加载到元空间，方法区的实现就是元空间的实现，类的字节码都会加载到元空间中，构成<strong>instanceklass</strong>这样的数据结构。加载的同时，在java堆中生成java_mirror的镜像</p>
<p>类的对象在对象头中保存了*.class的地址。让对象可以通过其找到方法区中的instanceKlass，从而获取类的各种信息</p>
<p>所有对象都在堆中包括类对象，当然c++对象例外</p>
<h2 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h2><p>分为三步骤：</p>
<ul>
<li>验证：验证类是否符合JVM规范，安全性检查</li>
<li>准备：为静态白变量分配空间，设置默认值</li>
</ul>
<p><strong>准备</strong></p>
<ul>
<li>static变量在JDK 7以后就存储在_java_mirror末尾了。静态变量存储在堆中。</li>
<li>static变量在<strong>分配空间</strong>和<strong>赋值</strong>是在两个阶段完成的。<strong>分配空间在准备阶段完成，赋值在初始化阶段完成</strong></li>
<li>如果 static 变量是 ﬁnal 的基本类型，以及字符串常量，那么编译阶段值就确定了，赋值在准备阶段完成</li>
<li>如果 static 变量是 ﬁnal 的，但属于引用类型，那么赋值也会在初始化阶段完成</li>
</ul>
<p><strong>解析</strong></p>
<p>将常量池中的符号引用解析为直接引用。</p>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><ul>
<li>初始化即调用<code>&lt;cinit&gt;()v</code> ，虚拟机会保证这个类的构造方法的线程安全。</li>
<li>初始化只是会加载静态变量、静态代码块，不会执行构造方法。</li>
<li>类加载不会执行cinit只有类初始化才会执行，然而static块会被放到cinit中，要是执行了就证明初始化了类</li>
<li>因为static块和static变量的初始化会在cinit方法中整合，而类的初始化就是执行cinit方法的过程</li>
<li>加载阶段就已经生成了mirror_class（也就是类.class），所以不会触发静态代码块</li>
</ul>
<p>类的初始化的<strong>懒惰</strong>的，以下情况会初始化：</p>
<ul>
<li><p>main 方法所在的类，总会被首先初始化</p>
</li>
<li><p>首次访问这个类的静态变量或静态方法时</p>
</li>
<li><p>子类初始化，如果父类还没初始化，会引发</p>
</li>
<li><p>子类访问父类的静态变量，只会触发父类的初始化</p>
</li>
<li><p>Class.forName默认导致类的触发</p>
</li>
<li><p>new 一个对象会导致对象的类初始化</p>
</li>
</ul>
<p>以下情况不会导致类的初始化：</p>
<ul>
<li><p>访问类的 static ﬁnal 静态常量（基本类型和字符串）不会触发。</p>
<p>因为在准备阶段，static final的常量就已经完成赋值了，以后直接使用值，不会触发类的初始化了</p>
</li>
<li><p>类对象.class 不会触发初始化</p>
</li>
<li><p>创建该类对象的数组</p>
</li>
<li><p>类加载器的.loadClass方法</p>
</li>
<li><p>Class.forName的参数2为false时</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Load3</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;main init&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="comment">// 1. 静态常量（基本类型和字符串）不会触发初始化</span></span><br><span class="line">        System.out.println(B.b);</span><br><span class="line">        <span class="comment">// 2. 类对象.class 不会触发初始化</span></span><br><span class="line">        System.out.println(B.class);</span><br><span class="line">        <span class="comment">// 3. 创建该类的数组不会触发初始化</span></span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">B</span>[<span class="number">0</span>]);</span><br><span class="line">        <span class="comment">// 4. 不会初始化类 B，但会加载 B、A</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">cl</span> <span class="operator">=</span> Thread.currentThread().getContextClassLoader();</span><br><span class="line">        cl.loadClass(<span class="string">&quot;cn.itcast.jvm.t3.B&quot;</span>);</span><br><span class="line">        <span class="comment">// 5. 不会初始化类 B，但会加载 B、A</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">c2</span> <span class="operator">=</span> Thread.currentThread().getContextClassLoader();</span><br><span class="line">        Class.forName(<span class="string">&quot;cn.itcast.jvm.t3.B&quot;</span>, <span class="literal">false</span>, c2);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 1. 首次访问这个类的静态变量或静态方法时</span></span><br><span class="line">        System.out.println(A.a);</span><br><span class="line">        <span class="comment">// 2. 子类初始化，如果父类还没初始化，会引发</span></span><br><span class="line">        System.out.println(B.c);</span><br><span class="line">        <span class="comment">// 3. 子类访问父类静态变量，只触发父类初始化</span></span><br><span class="line">        System.out.println(B.a);</span><br><span class="line">        <span class="comment">// 4. 会初始化类 B，并先初始化类 A</span></span><br><span class="line">        Class.forName(<span class="string">&quot;cn.itcast.jvm.t3.B&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;a init&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">double</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">5.0</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">c</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;b init&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>类的初始化就是执行cinit方法，这个方法包含了类中定义的静态代码块，所以其实是用静态代码块是否执行为依据来判断类是否初始化了。</p>
<ul>
<li>因为<code>main</code>被触发，所以一定会输出<strong>main init</strong></li>
</ul>
<ol>
<li><p>执行1时，因为引用的<code>B</code>中的<code>b</code>是常量，<code>B</code>不会初始化，没有不会触发<code>B</code>中的方法，所以只输出   5.0。</p>
<p><strong>解释</strong>：</p>
<ul>
<li><p>因为static块和static变量的初始化会在cinit方法中整合，而类的初始化就是执行cinit方法的过程。</p>
</li>
<li><p>类加载不会执行cinit只有类初始化才会执行，然而static块会被放到cinit中，要是执行了就证明初始化了类。</p>
</li>
</ul>
</li>
<li><p>会打印B.class，但不会触发初始化B。</p>
<p>解释：加载阶段就已经生成了mirror_class（也就是类.class），所以不会触发静态代码块。</p>
</li>
<li><p>解释：因为你数组存的也还是Minor对象，在加载时就创建了。数组只是预留个空间，没new。数组只充当个容器，和类没什么关系</p>
</li>
<li><p>class只会导致类的加载，解析和初始化都不执行。这里要注意加载指的是第一个阶段而不是整个过程</p>
</li>
<li><p>略。false，代表不初始化。</p>
</li>
<li><p>静态变量都会引起初始化，非final的静态方法也会</p>
</li>
<li><p>类a的初始化会导致类b的初始化，父类初始化在子类之前</p>
</li>
<li><p>略</p>
</li>
<li><p>略</p>
</li>
</ol>
<p>加载，用到的类都会加载，加载信息进内存（元空间），然后初始化开辟空间（堆中）静态在堆中</p>
<h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><table>
<thead>
<tr>
<th><strong>名称</strong></th>
<th><strong>加载的类</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Bootstrap ClassLoader（启动类加载器）</td>
<td>JAVA_HOME&#x2F;jre&#x2F;lib</td>
<td>无法直接访问</td>
</tr>
<tr>
<td>Extension ClassLoader(拓展类加载器)</td>
<td>JAVA_HOME&#x2F;jre&#x2F;lib&#x2F;ext</td>
<td>上级为Bootstrap，<strong>显示为null</strong></td>
</tr>
<tr>
<td>Application ClassLoader(应用程序类加载器)</td>
<td>classpath</td>
<td>上级为Extension</td>
</tr>
<tr>
<td>自定义类加载器</td>
<td>自定义</td>
<td>上级为Application</td>
</tr>
</tbody></table>
<p>第一遍自下而上有没有加载，有就终止返回，没有到bootstrap顶层后自上而下处理加载该类的任务。 </p>
<p>自定向下 尝试加载。这是为了<strong>防止核心类被篡改</strong></p>
<p><strong>启动类加载器是由c++程序编写，不能够通过Java代码直接访问。</strong></p>
<h3 id="启动类加载器"><a href="#启动类加载器" class="headerlink" title="启动类加载器"></a>启动类加载器</h3><p>用BootStrap类加载器加载类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.jvm.t3.load;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">F</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;bootstrap F init&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.jvm.t3.load;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Load5_1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        Class&lt;?&gt; aClass = Class.forName(<span class="string">&quot;cn.itcast.jvm.t3.load.F&quot;</span>);</span><br><span class="line">        System.out.println(aClass.getClassLoader());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">E:\git\jvm\out\production\jvm&gt;java -Xbootclasspath/a:.</span><br><span class="line">cn.itcast.jvm.t3.load.Load5</span><br><span class="line">bootstrap F init</span><br><span class="line">null</span><br></pre></td></tr></table></figure>

<ul>
<li><p>Xbootclasspath 表示设置 bootclasspath</p>
</li>
<li><p>其中 &#x2F;a:. 表示将当前目录追加至 bootclasspath 之后</p>
</li>
<li><p>可以用这个办法替换核心类</p>
<p>java -Xbootclasspath:<new bootclasspath></p>
</li>
<li><p>也可以追加</p>
<p>java -Xbootclasspath&#x2F;a:&lt;追加路径&gt;（后追加）<br>java -Xbootclasspath&#x2F;p:&lt;追加路径&gt;（前追加）</p>
</li>
</ul>
<h3 id="扩展类加载器"><a href="#扩展类加载器" class="headerlink" title="扩展类加载器"></a>扩展类加载器</h3><p>如果classpath和JAVA_HOME&#x2F;jre&#x2F;lib&#x2F;ext 下有同名类，加载时会使用<strong>拓展类加载器</strong>加载。当应用程序类加载器发现拓展类加载器已将该同名类加载过了，则不会再次加载</p>
<h3 id="双亲委派模式"><a href="#双亲委派模式" class="headerlink" title="双亲委派模式"></a>双亲委派模式</h3><p>双亲委派模式源码</p>
<p><img src="/filename/18.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="type">boolean</span> resolve)</span><br><span class="line">    <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">        <span class="comment">// 1. 检查该类是否已经加载</span></span><br><span class="line">        Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">t0</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (parent != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 2. 有上级的话，委派上级 loadClass</span></span><br><span class="line">                    c = parent.loadClass(name, <span class="literal">false</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 3. 如果没有上级了（ExtClassLoader），则委派</span></span><br><span class="line">                    <span class="type">BootstrapClassLoader</span></span><br><span class="line">                        <span class="variable">c</span> <span class="operator">=</span> findBootstrapClassOrNull(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="type">long</span> <span class="variable">t1</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">                <span class="comment">// 4. 每一层找不到，调用 findClass 方法（每个类加载器自己扩展）来加载</span></span><br><span class="line">                c = findClass(name);</span><br><span class="line">                <span class="comment">// 5. 记录耗时</span></span><br><span class="line">                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">            resolveClass(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><p>当AppClassLoader加载一个class时，它首先不会自己去尝试加载这个类，而是把类加载请求委派给父类加载器ExtClassLoader去完成。</p>
</li>
<li><p>当ExtClassLoader加载一个class时，它首先也不会自己去尝试加载这个类，而是把类加载请求委派给BootStrapClassLoader去完成。</p>
</li>
<li><p>如果BootStrapClassLoader加载失败(例如在$JAVA_HOME&#x2F;jre&#x2F;lib里未查找到该class)，会使用ExtClassLoader来尝试加载；</p>
</li>
<li><p>若ExtClassLoader也加载失败，则会使用AppClassLoader来加载，如果AppClassLoader也加载失败，则会报出异常ClassNotFoundException。</p>
</li>
<li><p>可以说是递归 因为都是调用父类ClassLoader的这个loadclass方法</p>
</li>
</ul>
<h3 id="线程上下文"><a href="#线程上下文" class="headerlink" title="线程上下文"></a>线程上下文</h3><p>某些情况打破双亲委派模式</p>
<p>SPI（ServiceLoader)机制是JDK提供接口，第三方Jar包实现，接口由启动类加载器加载，实现类不在JDK中，需要反向委派，由线程上下文加载器加载</p>
<p><code>com.mysql.jdbc.Driver</code>的加载器是<strong>Bootstrap ClassLoader</strong>，</p>
<p>jdbc是Java接口规范,接口类的加载肯定是在启动类加载器能加载目录下的,而实现这套规范的mysql的驱动肯定不在jre&#x2F;lib目录下，所以启动类加载器想要加载mysql驱动类肯定不行</p>
<p>双亲委派模型是低层级类加载器让高层级类加载器看是否能加载，如果能自己就不加载了，而这里是高层级调用低层级的，所以违反了双亲委派模型</p>
<p>DriverManager在rt包下，肯定是bootstrap来加载，但是mysql的Driver肯定是在别的包，就要用<strong>应用程序</strong>的类加载器</p>
<p>默认是使用本来的加载器加载依赖类的，由于JDBC在核心类库中，它由启动类加载器加载，由于驱动是在他的类初始化方法中加载的，所以驱动是DriverManager的依赖，默认是由启动类加载器加载，但找不到，不可能加载到驱动，于是要显示的调用Classd的forName方法使用一个能加载驱动的加载器加载驱动。</p>
<ul>
<li>我来总结下，在jre&#x2F;lib包下有一个DriverManager，是启动类加载的，但是jdbc的驱动是各个厂商来实现的不在启动类加</li>
<li>只能打破双亲委派，启动类直接请求系统类加载器去classpath下加载驱动（正常是向上委托，这个反过来了），而打破双亲委派的就是这个线程上下文类加载器载路径下，启动类无法加载，而驱动管理需要用到这些驱动</li>
<li>过程就是：启动类加载器加载DriverManager，DriverManager代码里调用了线程上下文类加载器，这个加载器默认就是使用应用程序类加载器加载类，通过应用程序类加载器加载<strong>jdbc</strong>驱动</li>
</ul>
<h3 id="自定义类加载器"><a href="#自定义类加载器" class="headerlink" title="自定义类加载器"></a>自定义类加载器</h3><p><strong>什么时候需要自定义类加载器？</strong></p>
<ul>
<li>想加载非 classpath 随意路径中的类文件。想加载的文件即不在启动，也不再扩展，也不再classpath下。想找任意路径下的类文件。</li>
<li>通过接口来使用实现，希望解耦时，常用在框架设计</li>
<li>这些类希望予以隔离，不同应用的同名类都可以加载，不冲突，常见于 <strong>tomcat 容器</strong></li>
</ul>
<p>步骤：</p>
<ul>
<li>继承 ClassLoader 父类</li>
<li>要遵从双亲委派机制，重写 ﬁndClass 方法，这样才能委托上级类加载器进行优先加载。只有上级类加载器没有找到class时候，调用findclass在本身查找。<br>不是重写 loadClass 方法，否则不会走双亲委派机制</li>
<li>读取类文件的字节码，一般是byte数组</li>
<li>调用父类的 deﬁneClass 方法来加载类</li>
<li>对于类加载器的使用者调用该类加载器的 loadClass 方法</li>
</ul>
<h2 id="运行期优化"><a href="#运行期优化" class="headerlink" title="运行期优化"></a>运行期优化</h2><p>JVM将执行状态分成5个层次：</p>
<ul>
<li><p>0层，解释执行。</p>
</li>
<li><p>1层：使用 C1 即时编译器编译执行（不带 proﬁling）</p>
</li>
<li><p>2层：使用 C1 即时编译器编译执行（带基本的profiling）</p>
</li>
<li><p>3层：使用 C1 即时编译器编译执行（带完全的profiling）</p>
</li>
<li><p>4层：使用 C2 即时编译器编译执行</p>
</li>
</ul>
<p>0层，字节码加载到虚拟机之后，靠解释器一个字节一个字节去解释执行。解释器将字节码解释为真正的字节码，cpu就能识别执行了。字节码反复调用使用，到达一定阈值之后。启用编译器就字节码进行编译执行，从0层上升到一层。编译器分为C1和C2。C1和C2的优化程度不一样，可以认为C1只做些基本的优化，C2做的更彻底，更完全的优化。C1比C2多做了些<strong>profiling</strong>信息统计操作。proﬁling 是指在运行过程中收集一些程序执行状态（字节码运行状态）的数据，例如【方法的调用次数】，【循环的回边次数】等。统计发现某方法频繁的调用，将会上升为C2编译器进行更完全，更彻底的优化。</p>
<h3 id="即时编译器（JIT）与解释器的区别"><a href="#即时编译器（JIT）与解释器的区别" class="headerlink" title="即时编译器（JIT）与解释器的区别"></a><strong>即时编译器（JIT）与解释器的区别</strong></h3><p>解释器</p>
<ul>
<li>将字节码解释为机器码，下次即使遇到相同的字节码，仍会执行重复的解释</li>
<li>是将字节码解释为针对所有平台都通用的机器码</li>
</ul>
<p>即时编译器</p>
<ul>
<li>将一些字节码编译为机器码，并存入 Code Cache，下次遇到相同的代码，直接执行，无需再编译</li>
<li>JIT根据平台类型，生成平台特定的机器码。（<em>因为你编译的Java源码不知道放在哪个平台执行，要实现跨平台就要先编译成统一的字节码文件，再针对不同平台解析对应平台的机器码</em>）</li>
</ul>
<p>对于大部分的不常用的代码，我们无需耗费时间将其编译成机器码，而是采取解释执行的方式运行；另一方面，对于仅占据小部分的热点代码，我们则可以将其编译成机器码，以达到理想的运行速度。 执行效率上简单比较一下 Interpreter &lt; C1 &lt; C2<em>（C1可以提升5倍左右，C2的执行效率可以提升10到100倍）</em>，总的目标是发现热点代码（hotspot名称的由 来），并优化这些热点代码。</p>
<h3 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h3><p>发现创建的对象，不会被用到。在C2中改掉。</p>
<p>作用：通过逃逸分析后的对象，可将这些对象直接在栈上进行分配，而非堆上。极大的降低了GC次数，从而提升了程序整体的执行效率。也就是没有逸出线程栈时，对象分配在栈上而不是在堆上，这样对象跟随栈消亡。确定逃逸的对象通过“标量替换”将该对象分解在栈上分配内存。</p>
<p><strong>逃逸分析的 JVM 参数如下</strong>：</p>
<ul>
<li>开启逃逸分析：-XX:+DoEscapeAnalysis</li>
<li>关闭逃逸分析：-XX:-DoEscapeAnalysis</li>
<li>显示分析结果：-XX:+PrintEscapeAnalysis</li>
</ul>
<p>逃逸分析技术在 Java SE 6u23+ 开始支持，并默认设置为启用状态，<strong>可以不用额外加这个参数</strong></p>
<p>参数逃逸（ArgEscape）：即一个对象被作为方法参数传递或者被参数引用，但在调用过程中不会发生全局逃逸，这个状态是通过被调方法的字节码确定的</p>
<p>没有逃逸：即方法中的对象没有发生逃逸</p>
<h4 id="逃逸分析优化"><a href="#逃逸分析优化" class="headerlink" title="逃逸分析优化"></a><strong>逃逸分析优化</strong></h4><p>针对上面第三点，当一个对象没有逃逸时，可以得到以下几个虚拟机的优化：</p>
<p><strong>锁消除</strong><br>我们知道线程同步锁是非常牺牲性能的，当编译器确定当前对象只有当前线程使用，那么就会移除该对象的同步锁<br>例如，StringBuffer 和 Vector 都是用 synchronized 修饰线程安全的，但大部分情况下，它们都只是在当前线程中用到，这样编译器就会优化移除掉这些锁操作<br>锁消除的 JVM 参数如下：</p>
<p>开启锁消除：-XX:+EliminateLocks<br>关闭锁消除：-XX:-EliminateLocks<br>锁消除在 JDK8 中都是默认开启的，并且锁消除都要建立在逃逸分析的基础上</p>
<p><strong>标量替换</strong><br>首先要明白标量和聚合量，基础类型和对象的引用可以理解为标量，它们不能被进一步分解。而能被进一步分解的量就是聚合量，比如：对象<br>对象是聚合量，它又可以被进一步分解成标量，将其成员变量分解为分散的变量，这就叫做标量替换。</p>
<p>这样，如果一个对象没有发生逃逸，那压根就不用创建它，只会在栈或者寄存器上创建它用到的成员标量，节省了内存空间，也提升了应用程序性能<br>标量替换的 JVM 参数如下：</p>
<p>开启标量替换：-XX:+EliminateAllocations<br>关闭标量替换：-XX:-EliminateAllocations<br>显示标量替换详情：-XX:+PrintEliminateAllocations<br>标量替换同样在 JDK8 中都是默认开启的，并且都要建立在逃逸分析的基础上</p>
<p><strong>栈上分配</strong><br>当对象没有发生逃逸时，该对象就可以通过标量替换分解成成员标量分配在栈内存中，和方法的生命周期一致，随着栈帧出栈时销毁，减少了 GC 压力，提高了应用程序性能</p>
<h3 id="方法内联"><a href="#方法内联" class="headerlink" title="方法内联"></a>方法内联</h3><p>也是即时编译器优化手段的一种。</p>
<p>如果发现调用的方法是热点方法，并且长度不会特别长，会进行内连，所谓的内联就是把方法内代码拷贝，粘贴到调用者的位置，还可以进行常量折叠的优化。</p>
<p>第二种情况，C++ 是否为内联函数由自己决定，Java 由编译器决定。Java 不支持直接声明为内联函数的，如果想让他内联，你只能够向编译器提出请求: 关键字 final 修饰 用来指明那个函数是希望被 JVM 内联的，如</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="comment">// to do something  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总的来说，一般的函数都不会被当做内联函数，只有声明了final后，编译器才会考虑是不是要把你的函数变成内联函数</p>
<p>JVM内建有许多运行时优化。首先短方法更利于JVM推断。流程更明显，作用域更短，副作用也更明显。如果是长方法JVM可能直接就跪了。</p>
<h3 id="反射优化"><a href="#反射优化" class="headerlink" title="反射优化"></a>反射优化</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Reflect1</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;foo...&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchMethodException, InvocationTargetException, IllegalAccessException &#123;</span><br><span class="line">      <span class="type">Method</span> <span class="variable">foo</span> <span class="operator">=</span> Demo3.class.getMethod(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt;=<span class="number">16</span>; i++) &#123;</span><br><span class="line">         foo.invoke(<span class="literal">null</span>);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>foo.invoke 前面 0 ~ 15 次调用使用的是 MethodAccessor 的 NativeMethodAccessorImpl 实现，第十七次开始性能变高<br>invoke 方法源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CallerSensitive</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object obj, Object... args)</span></span><br><span class="line">    <span class="keyword">throws</span> IllegalAccessException, IllegalArgumentException,</span><br><span class="line">       InvocationTargetException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!override) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!Reflection.quickCheckMemberAccess(clazz, modifiers)) &#123;</span><br><span class="line">            Class&lt;?&gt; caller = Reflection.getCallerClass();</span><br><span class="line">            checkAccess(caller, clazz, obj, modifiers);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//MethodAccessor是一个接口，有3个实现类，其中有一个是抽象类</span></span><br><span class="line">    <span class="type">MethodAccessor</span> <span class="variable">ma</span> <span class="operator">=</span> methodAccessor;             <span class="comment">// read volatile</span></span><br><span class="line">    <span class="keyword">if</span> (ma == <span class="literal">null</span>) &#123;</span><br><span class="line">        ma = acquireMethodAccessor();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ma.invoke(obj, args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在  <code>MethodAccesso</code>中会<code>DelegatingMethodAccessorImpl</code>调用<code>NativeMethodAccessorImpl</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> sun.reflect;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> sun.reflect.misc.ReflectUtil;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NativeMethodAccessorImpl</span> <span class="keyword">extends</span> <span class="title class_">MethodAccessorImpl</span> &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Method method;</span><br><span class="line"><span class="keyword">private</span> DelegatingMethodAccessorImpl parent;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> numInvocations;</span><br><span class="line">NativeMethodAccessorImpl(Method method) &#123;</span><br><span class="line"><span class="built_in">this</span>.method = method;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object target, Object[] args)</span></span><br><span class="line"><span class="keyword">throws</span> IllegalArgumentException, InvocationTargetException &#123;</span><br><span class="line"><span class="comment">// inflationThreshold 膨胀阈值，默认 15</span></span><br><span class="line"><span class="keyword">if</span> (++<span class="built_in">this</span>.numInvocations &gt; ReflectionFactory.inflationThreshold()</span><br><span class="line">&amp;&amp; !ReflectUtil.isVMAnonymousClass(<span class="built_in">this</span>.method.getDeclaringClass()))</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 使用 ASM 动态生成的新实现代替本地实现，速度较本地实现快 20 倍左右</span></span><br><span class="line"><span class="type">MethodAccessorImpl</span> <span class="variable">generatedMethodAccessor</span> <span class="operator">=</span></span><br><span class="line">(MethodAccessorImpl)</span><br><span class="line">(<span class="keyword">new</span> <span class="title class_">MethodAccessorGenerator</span>())</span><br><span class="line">.generateMethod(</span><br><span class="line"><span class="built_in">this</span>.method.getDeclaringClass(),</span><br><span class="line"><span class="built_in">this</span>.method.getName(),</span><br><span class="line"><span class="built_in">this</span>.method.getParameterTypes(),</span><br><span class="line"><span class="built_in">this</span>.method.getReturnType(),</span><br><span class="line"><span class="built_in">this</span>.method.getExceptionTypes(),</span><br><span class="line"><span class="built_in">this</span>.method.getModifiers()</span><br><span class="line">);</span><br><span class="line"><span class="built_in">this</span>.parent.setDelegate(generatedMethodAccessor);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用本地实现</span></span><br><span class="line"><span class="keyword">return</span> invoke0(<span class="built_in">this</span>.method, target, args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">setParent</span><span class="params">(DelegatingMethodAccessorImpl parent)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.parent = parent;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> Object <span class="title function_">invoke0</span><span class="params">(Method method, Object target, Object[]</span></span><br><span class="line"><span class="params">args)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>前十五次调用的都是本地方法，当调用到第 16 次（从0开始算）时，会采用运行时生成的类代替掉最初的实现，可以通过 debug 得到 类名为 <code>sun.reflect.GeneratedMethodAccessor1</code>。</p>
<p>生成了虚拟类 直接调用了，从反射方法调用变为正常方法调用。</p>
<p>本地方法相对于 java方法来说较慢，要不说少用反射，反射创建对象虽然好但是会降低性能</p>
<p>通过查看 ReflectionFactory 源码可知 </p>
<ul>
<li>sun.reflect.noInflation 可以用来禁用膨胀（直接生成 GeneratedMethodAccessor1，但首 次生成比较耗时，如果仅反射调用一次，不划算） </li>
<li>sun.reflect.inflationThreshold 可以修改膨胀阈值</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/09/19/experience/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="LLCH Liu">
      <meta itemprop="description" content="Here we go!!!!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Here We Go">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/09/19/experience/" class="post-title-link" itemprop="url">调优经验</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-09-19 17:51:55 / 修改时间：23:57:43" itemprop="dateCreated datePublished" datetime="2023-09-19T17:51:55+08:00">2023-09-19</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JVM/" itemprop="url" rel="index"><span itemprop="name">-JVM</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="调优经验"><a href="#调优经验" class="headerlink" title="调优经验"></a>调优经验</h1><h2 id="GC调优"><a href="#GC调优" class="headerlink" title="GC调优"></a>GC调优</h2><h3 id="前置经验"><a href="#前置经验" class="headerlink" title="前置经验"></a>前置经验</h3><h4 id="经常发生GC"><a href="#经常发生GC" class="headerlink" title="经常发生GC"></a><strong>经常发生GC</strong></h4><ul>
<li><p>数据太多</p>
<p>resultSet &#x3D;statement.executeQuery(“select * from 大表 limit in”)</p>
</li>
<li><p>数据表示太臃肿？</p>
<p>只显示用户一部分数据就够。</p>
</li>
<li><p>是否存在内存泄露</p>
<p>长时间存活对象比如（static），尝试软弱引用，第三方缓存实现</p>
</li>
</ul>
<h4 id="新生代调优"><a href="#新生代调优" class="headerlink" title="新生代调优"></a><strong>新生代调优</strong></h4><ul>
<li>TLAB thread-local allocation buffer（可防止多个线程创建对象时的互相干扰混乱）</li>
<li>当新生代发生垃圾回收（新生代都是复制算法），在Eden区域及幸存区<strong>from</strong>对象复制到<strong>to</strong>中。</li>
<li>Oracle建议新生代大于1&#x2F;4并且小于1&#x2F;2 overall heap size。</li>
<li><code>-XX:+PrintTenuringDistribution</code> 可以显示详细信息</li>
</ul>
<h4 id="老年代内存预设"><a href="#老年代内存预设" class="headerlink" title="老年代内存预设"></a>老年代内存预设</h4><p><code>-XX:CMSInitiatingOccupancyFraction=percent</code>（越大越好，twitter工程师建议设置为0。一般设置为75%~80%）</p>
<h3 id="实战案例"><a href="#实战案例" class="headerlink" title="实战案例"></a>实战案例</h3><h4 id="Full-GC和Minor-GC频繁"><a href="#Full-GC和Minor-GC频繁" class="headerlink" title="Full GC和Minor GC频繁"></a>Full GC和Minor GC频繁</h4><p>空间紧张，先从新生代开始看，可能是新生代空间太小的原因，新生代空间宽裕了就不再那么频繁了。</p>
<h4 id="请求高峰期发生Full-GC，单次暂停时间特别长（CMS）"><a href="#请求高峰期发生Full-GC，单次暂停时间特别长（CMS）" class="headerlink" title="请求高峰期发生Full GC，单次暂停时间特别长（CMS）"></a>请求高峰期发生Full GC，单次暂停时间特别长（CMS）</h4><p>查看GC日志，要扫描整个堆内存。发现是重新扫描时间过长，使用<code>-XX:+CMSScavengeBeforceRemark</code>在重新你扫描前进行一次垃圾回收</p>
<hr>
<h3 id="线程诊断"><a href="#线程诊断" class="headerlink" title="线程诊断"></a>线程诊断</h3><h3 id="实战案例-1"><a href="#实战案例-1" class="headerlink" title="实战案例"></a>实战案例</h3><h4 id="cpu占用过多"><a href="#cpu占用过多" class="headerlink" title="cpu占用过多"></a>cpu占用过多</h4><p> top 先定位到CPU 占用高的 Java 进程，再利用 top -Hp 进程id 来定位是哪个线程，最后再用 jstack 排查</p>
<ul>
<li><p>使用top命令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用命令查看进程中的线程              pid：进程id，       tid：线程id</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ps H -eo pid,tid,%cpu</span><br><span class="line"></span><br><span class="line">ps H -eo pid,tid,%cpu | grep 进程id      //只留下感兴趣的进程</span><br></pre></td></tr></table></figure>
</li>
<li><p>将得到的线程id转化为16进制，在thread[x]，找出具体的thread</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstack 线程id</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="迟迟得不到结果"><a href="#迟迟得不到结果" class="headerlink" title="迟迟得不到结果"></a>迟迟得不到结果</h4><p>可能出现了死锁。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/09/19/%E8%B0%83%E4%BC%98%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="LLCH Liu">
      <meta itemprop="description" content="Here we go!!!!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Here We Go">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/09/19/%E8%B0%83%E4%BC%98%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/" class="post-title-link" itemprop="url">调优常用命令</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-09-19 17:50:14 / 修改时间：23:27:04" itemprop="dateCreated datePublished" datetime="2023-09-19T17:50:14+08:00">2023-09-19</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="查看虚拟机运行参数"><a href="#查看虚拟机运行参数" class="headerlink" title="查看虚拟机运行参数"></a>查看虚拟机运行参数</h4><p><code>java -XX:+PrintFlagsFinal -version | grep GC</code></p>
<h4 id="显示新老年代详细信息"><a href="#显示新老年代详细信息" class="headerlink" title="显示新老年代详细信息"></a>显示新老年代详细信息</h4><p><code>-XX:+PrintTenuringDistribution</code></p>
<h4 id="老年代内存预设"><a href="#老年代内存预设" class="headerlink" title="老年代内存预设"></a>老年代内存预设</h4><p><code>-XX:CMSInitiatingOccupancyFraction=percent</code>（越大越好，twitter工程师建议设置为0。一般设置为75%~80%）</p>
<h4 id="堆内存溢出诊断"><a href="#堆内存溢出诊断" class="headerlink" title="堆内存溢出诊断"></a>堆内存溢出诊断</h4><p>可以通过<strong>反编译</strong><code>javac xxx.java</code>来查看类的信息</p>
<ul>
<li><p>jps工具</p>
<p>查看当前系统哪些java进程</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jps</span><br></pre></td></tr></table></figure>


</li>
<li><p>jmap工具</p>
<p>查看堆内存占用情况，只能查看某一时刻的状态</p>
<p>Heap Configuration:堆的设置</p>
<p>Heap Usage &#x2F; Eden Space &#x2F;used：查看占用内存</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmap -heap 进程id</span><br></pre></td></tr></table></figure>
</li>
<li><p>jconsole工具</p>
<p>图形界面工具，可以连续监测</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jconsole</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h4><h5 id="垃圾回收后内存过高"><a href="#垃圾回收后内存过高" class="headerlink" title="垃圾回收后内存过高"></a>垃圾回收后内存过高</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jvisualvm</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="吞吐量优先-Parallel-Scavenge收集器"><a href="#吞吐量优先-Parallel-Scavenge收集器" class="headerlink" title="吞吐量优先(Parallel Scavenge收集器)"></a>吞吐量优先(Parallel Scavenge收集器)</h4><p>多线程，堆内存较大，多核CPU。单位时间内，STW的时间最短。总时间最短。</p>
<p><strong>开启垃圾回收器</strong>：vm参数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseParallelGC~-XX:+UseParalleOldGC</span><br></pre></td></tr></table></figure>

<p>1.8都默认开启前者代表是新生代的垃圾回收器，使用的是复制算法；后者工作在老年代，采用标记整理算法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:ParallelGCThreads=n</span><br></pre></td></tr></table></figure>

<p>控制ParallelGC运行时的线程数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseAdaptiveSizePolicy</span><br></pre></td></tr></table></figure>

<p>新生代自适应大小调整策略</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:GCTimeRatio=ratio</span><br></pre></td></tr></table></figure>

<p>调节垃圾回收时间和总时间的占比。1&#x2F;(ratio+1)，垃圾回收总时间占比</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:MaxGCPauseMillis=ms</span><br></pre></td></tr></table></figure>

<p>每次垃圾回收最大暂停毫秒数</p>
<h4 id="响应时间优先（CMS"><a href="#响应时间优先（CMS" class="headerlink" title="响应时间优先（CMS)"></a>响应时间优先（CMS)</h4><p>多线程，-堆内存较大，多核CPU。尽可能让单次STW时间最短。适用于关注响应速度的服务</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseConcMarkSweepGC-XX:+UseParNewGC~SerialOld</span><br></pre></td></tr></table></figure>

<p>基于标记清除算法的垃圾回收器。该算法导致过度内存碎片,分配对象时MinorGC不足，老年代也不足，导致并发失败，CMSGC退化为SerialOld，单线程串行的垃圾回收。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:ParallelGCThreads=n~-XX:ConGCThreads=threads</span><br></pre></td></tr></table></figure>

<p>前者：并行的垃圾回收线程数，一般跟cpu核数一样。</p>
<p>后者：并发的垃圾回收线程数，一般设为并行线程数的四分之一。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:CMSInitiatingOccupancyFraction=percent</span><br></pre></td></tr></table></figure>

<p>作用：并发清理的时候会产生新的垃圾，不能等到内存不足了才去清理。要预留空间给浮动垃圾。值设置的越小，触发时机越早。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+CMSScavengeBeforceRemark</span><br></pre></td></tr></table></figure>

<p>作用：在重新标记前对新生代的进行垃圾回收，新生代存活对象少，减轻重新标记压力。（+打开，-关闭）</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/09/14/JVM/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="LLCH Liu">
      <meta itemprop="description" content="Here we go!!!!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Here We Go">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/09/14/JVM/" class="post-title-link" itemprop="url">JVM-内存结构及垃圾回收</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-09-14 20:35:51" itemprop="dateCreated datePublished" datetime="2023-09-14T20:35:51+08:00">2023-09-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-09-21 12:12:14" itemprop="dateModified" datetime="2023-09-21T12:12:14+08:00">2023-09-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JVM/" itemprop="url" rel="index"><span itemprop="name">-JVM</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="什么是JVM"><a href="#什么是JVM" class="headerlink" title="什么是JVM?"></a>什么是JVM?</h2><p><strong>Java Virtual Machine</strong> - java程序的运行环境（Java 二进制字节码的运行环境）</p>
<p>屏蔽Java代码与底层操作系统的差异</p>
<ul>
<li>对外提供一致的运行环境（平台无关性）</li>
<li>自动内存管理，垃圾回收功能</li>
<li>数组下标越界检查（抛异常比新元素覆盖程序其他部分强）</li>
<li>多态</li>
</ul>
<p><strong>JRE</strong> :        JVM+基础类库（日期类等等IO类）</p>
<p>**JDK ** :      JVM+编译工具（javac,  Javap，内存检测工具等等）</p>
<p><strong>开发JavaSE程序</strong>：   JDK + IDE工具</p>
<p><strong>开发JavaEE程序</strong>：   JDK+IDE工具+应用服务器（tomcat)</p>
<h2 id="JVM组成"><a href="#JVM组成" class="headerlink" title="JVM组成:"></a>JVM组成:</h2><p><img src="/filename/1.png" alt="https://github.com/LiuLCH1014/LiuLCH1014.github.io/blob/main/filename/1.png"></p>
<p>java源代码编译为二进制字节码以后(Java class),经过类加载器(classLoader),才能加载到JVM内存结构中被运行。</p>
<p>类都是放在方法区，类创建的实例对象放在堆，实例对象调用方法时用到虚拟机栈等</p>
<p>方法执行时由执行引擎中的解释器逐行解释，即时编译器优化执行频繁调用的代码。</p>
<p>GC会对堆中不再引用的对象垃圾回收。</p>
<p>Java代码中不方便实现的功能，本地接口调用本地操作系统提供的功能方法</p>
<hr>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><h4 id="垃圾回收是否涉及栈内存？"><a href="#垃圾回收是否涉及栈内存？" class="headerlink" title="垃圾回收是否涉及栈内存？"></a>垃圾回收是否涉及栈内存？</h4><p>栈自动出栈，不需要垃圾回收管理栈内存</p>
<h4 id="栈内存分配越大越好吗"><a href="#栈内存分配越大越好吗" class="headerlink" title="栈内存分配越大越好吗"></a>栈内存分配越大越好吗</h4><p>栈越大，线程数越少</p>
<h4 id="方法内的局部变量是否线程安全"><a href="#方法内的局部变量是否线程安全" class="headerlink" title="方法内的局部变量是否线程安全-"></a>方法内的局部变量是否线程安全-</h4><p>这要看这个变量是对每个线程共享的，还是每个线程私有的。共享的不用考虑线程安全。</p>
<p>如果是static，<strong>静态变量属于类</strong>，放在方法区，属于线程共享的数据。</p>
<p>StringBuilder本来就不是线程安全的，如果用StringBuffer就是线程安全的。</p>
<p>是不是线程安全不仅要看是否是方法内的局部变量，也要看是否逃离方法的作用范围。</p>
<h4 id="栈—内存溢出"><a href="#栈—内存溢出" class="headerlink" title="栈—内存溢出"></a>栈—内存溢出</h4><ul>
<li>线程请求的栈深度大于虚拟机所允许的最大深度，抛出StackOverflowError</li>
<li>虚拟机的栈内存如果允许动态扩展，当栈容量无法申请到足够的内存抛出 OutOfMemoryError</li>
</ul>
<hr>
<h2 id="JVM内存结构"><a href="#JVM内存结构" class="headerlink" title="JVM内存结构"></a>JVM内存结构</h2><h3 id="程序计数器——Program-Counter-Register"><a href="#程序计数器——Program-Counter-Register" class="headerlink" title="程序计数器——Program Counter Register"></a>程序计数器——Program Counter Register</h3><p>记住下一条<strong>jvm指令</strong>的执行地址（寄存器）</p>
<ul>
<li><strong>线程私有</strong>  每个线程都有自己的register</li>
<li>不会存在内存溢出</li>
</ul>
<hr>
<h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>线程运行需要的内存空间</p>
<p>不指定大小Linux，Oracle，macSO都是<strong>1024k</strong></p>
<p>windows会根据虚拟内存影响栈的大小</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-Xss size</span><br><span class="line"></span><br><span class="line">//example</span><br><span class="line">-Xss 1m</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="栈帧"><a href="#栈帧" class="headerlink" title="栈帧"></a>栈帧</h4><p><em><strong>每个方法需要的内存</strong></em>（参数，局部变量，返回地址）</p>
<hr>
<h4 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h4><p>用c和c++编写的本地方法，来真正与操作系统和本地API打交道，可以间接使用本地方法，这些本地方法使用的栈就是本地方法栈。</p>
<p>native方法有C&#x2F;C++底层实现。</p>
<p>当调用本地方法时程序计数器为空。</p>
<hr>
<h3 id="Heap-堆"><a href="#Heap-堆" class="headerlink" title="Heap 堆"></a>Heap 堆</h3><p>   通过<strong>new</strong>关键字，创建对象都会使用堆内存</p>
<ul>
<li>它是线程共享的，堆中对象都需要考虑线程安全问题</li>
<li>有垃圾回收机制</li>
</ul>
<hr>
<h4 id="堆内存溢出诊断"><a href="#堆内存溢出诊断" class="headerlink" title="堆内存溢出诊断"></a>堆内存溢出诊断</h4><p>可以通过<strong>反编译</strong><code>javac xxx.java</code>来查看类的信息</p>
<ul>
<li><p>jps工具</p>
<p>查看当前系统哪些java进程</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jps</span><br></pre></td></tr></table></figure>


</li>
<li><p>jmap工具</p>
<p>查看堆内存占用情况，只能查看某一时刻的状态</p>
<p>Heap Configuration:堆的设置</p>
<p>Heap Usage &#x2F; Eden Space &#x2F;used：查看占用内存</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmap -heap 进程id</span><br></pre></td></tr></table></figure>
</li>
<li><p>jconsole工具</p>
<p>图形界面工具，可以连续监测</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jconsole</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h4><h5 id="垃圾回收后内存过高"><a href="#垃圾回收后内存过高" class="headerlink" title="垃圾回收后内存过高"></a>垃圾回收后内存过高</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jvisualvm</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="方法区-Method-Area"><a href="#方法区-Method-Area" class="headerlink" title="方法区-Method Area"></a>方法区-Method Area</h3><p>会受到内存限制，抛出<strong>OutOfMemoryError</strong>异常</p>
<p><img src="/filename/2.png" alt="https://github.com/LiuLCH1014/LiuLCH1014.github.io/blob/main/filename/2.png"></p>
<p>方法区是所有java虚拟机线程的<strong>共享</strong>的区，用于存储已被虚拟机加载的类型信息，常量，静态变量，即时编译器编译后的代码缓存等数据</p>
<p>JDK1.8版本之前方法区用的堆的内存，叫<strong>永久代</strong>，JDK1.8之后用的操作系统的内存，叫<strong>元空间</strong>。</p>
<p>元空间被在本地内存中</p>
<p>永久代是方法区的实现，方法区也是一种规范，具体的实现是永久代和元空间，不同的厂商实现方式不同</p>
<h3 id="运行时常量池-Runtime-Constant-Pool"><a href="#运行时常量池-Runtime-Constant-Pool" class="headerlink" title="运行时常量池-Runtime Constant Pool"></a>运行时常量池-Runtime Constant Pool</h3><p>常量池表（存放编译时期生成的字面量和符号引用）在类加载后存放到方法区的运行时常量池中。</p>
<p>动态性   Java语言并不要求常量编译时产生，运行期间也可以将新的常量放入池中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string1.intern();</span><br></pre></td></tr></table></figure>

<p>intern方法，主动将<strong>串池中还没有的字符串对象</strong>放入串池，</p>
<p>将字符串对象s1尝试放入串池，<strong>如果原来存在有并不会放入</strong>，<strong>还会在堆中</strong>，如果没有则放入串池，会把串池的对象返回。</p>
<h3 id="StringTable"><a href="#StringTable" class="headerlink" title="StringTable"></a>StringTable</h3><p>stringtable是串池，<strong>串池是常量池中的一部分</strong>。</p>
<p>垃圾回收不会发生在永久代(PermGen space)，如果永久代满了或者是超过了临界值，会触发完全垃圾回收(Full GC)。</p>
<h4 id="stringTable性能调优"><a href="#stringTable性能调优" class="headerlink" title="stringTable性能调优"></a>stringTable性能调优</h4><ul>
<li><p>主要调整hashTable桶的个数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:SringTableSize=×××</span><br></pre></td></tr></table></figure>
</li>
<li><p>考虑字符串对象是否入池</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//example</span></span><br><span class="line">intern();</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itcast.itheima.xpp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        String s1=<span class="string">&quot;a&quot;</span>;</span><br><span class="line">        String s2=<span class="string">&quot;b&quot;</span>;</span><br><span class="line">        String s3=<span class="string">&quot;a&quot;</span>+<span class="string">&quot;b&quot;</span>;</span><br><span class="line">        String s4=s1+s2;</span><br><span class="line">        String s5=<span class="string">&quot;ab&quot;</span>;</span><br><span class="line">        String s6=s4.intern();</span><br><span class="line">        System.out.println(s3==s4);<span class="comment">//false</span></span><br><span class="line">        System.out.println(s3==s5);<span class="comment">//true</span></span><br><span class="line">        System.out.println(s3==s6);<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">        String x2=<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;c&quot;</span>)+<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;d&quot;</span>);</span><br><span class="line">        String x1=<span class="string">&quot;cd&quot;</span>;</span><br><span class="line">        x2.intern();</span><br><span class="line">        System.out.println(x1==x2);<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        String x4=<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;e&quot;</span>)+<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;f&quot;</span>);</span><br><span class="line">        x4.intern();</span><br><span class="line">        String x3=<span class="string">&quot;ef&quot;</span>;</span><br><span class="line">        System.out.println(x3==x4);<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h3><p>这部分被频繁引用，也会导致<strong>OutOfMemoryError</strong></p>
<p>一般配置虚拟机参数，会根据实际内存去设置-Xmx等参数信息，但经常忽略直接内存，从而导致动态扩展出现OutOfMemoeryError。</p>
<p>NIO类引入了一种基于通道与缓存区的I&#x2F;O方式，可以使用Native函数库直接分配<strong>堆外内存</strong>，通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。<strong>避免了在Java堆和Native堆中来回复制</strong>。</p>
<p><img src="/filename/3.png" alt="https://github.com/LiuLCH1014/LiuLCH1014.github.io/blob/main/filename/3.png"></p>
<p>通过两次缓冲区，效率不高</p>
<hr>
<h4 id="直接内存回收原理"><a href="#直接内存回收原理" class="headerlink" title="直接内存回收原理"></a>直接内存回收原理</h4><ul>
<li>使用了 Unsafe 类来完成直接内存的分配回收，回收需要主动调用<code>freeMemory</code> 方法</li>
<li>ByteBuffer 的实现内部使用了 Cleaner（虚引用）来检测 ByteBuffer 。一旦ByteBuffer 被垃圾回收，那么会由 ReferenceHandler（守护线程） 来调用 <code>Cleaner.clean</code> 方法调用 <strong>freeMemory</strong> 来释放内存</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Code_06_DirectMemoryTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">_1GB</span> <span class="operator">=</span> <span class="number">1024</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, NoSuchFieldException, IllegalAccessException &#123;</span><br><span class="line"><span class="comment">//        method();</span></span><br><span class="line">        method1();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 演示 直接内存 是被 unsafe 创建与回收</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span> <span class="keyword">throws</span> IOException, NoSuchFieldException, IllegalAccessException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> Unsafe.class.getDeclaredField(<span class="string">&quot;theUnsafe&quot;</span>);</span><br><span class="line">        field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">Unsafe</span> <span class="variable">unsafe</span> <span class="operator">=</span> (Unsafe)field.get(Unsafe.class);</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">base</span> <span class="operator">=</span> unsafe.allocateMemory(_1GB);</span><br><span class="line">        unsafe.setMemory(base,_1GB, (<span class="type">byte</span>)<span class="number">0</span>);</span><br><span class="line">        System.in.read();</span><br><span class="line"></span><br><span class="line">        unsafe.freeMemory(base);</span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 演示 直接内存被 释放</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">byteBuffer</span> <span class="operator">=</span> ByteBuffer.allocateDirect(_1GB);</span><br><span class="line">        System.out.println(<span class="string">&quot;分配完毕&quot;</span>);</span><br><span class="line">        System.in.read();</span><br><span class="line">        System.out.println(<span class="string">&quot;开始释放&quot;</span>);</span><br><span class="line">        byteBuffer = <span class="literal">null</span>;</span><br><span class="line">        System.gc(); <span class="comment">// 手动 gc</span></span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>直接内存的回收不是通过 JVM 的垃圾回收来释放的，而是通过<code>unsafe.freeMemory</code> 来手动释放。</strong><br>第一步：allocateDirect 的实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ByteBuffer <span class="title function_">allocateDirect</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DirectByteBuffer</span>(capacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>底层是创建了一个 DirectByteBuffer 对象。<br>第二步：DirectByteBuffer 类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">DirectByteBuffer(<span class="type">int</span> cap) &#123;   <span class="comment">// package-private</span></span><br><span class="line">   </span><br><span class="line">    <span class="built_in">super</span>(-<span class="number">1</span>, <span class="number">0</span>, cap, cap);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">pa</span> <span class="operator">=</span> VM.isDirectMemoryPageAligned();</span><br><span class="line">    <span class="type">int</span> <span class="variable">ps</span> <span class="operator">=</span> Bits.pageSize();</span><br><span class="line">    <span class="type">long</span> <span class="variable">size</span> <span class="operator">=</span> Math.max(<span class="number">1L</span>, (<span class="type">long</span>)cap + (pa ? ps : <span class="number">0</span>));</span><br><span class="line">    Bits.reserveMemory(size, cap);</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="variable">base</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        base = unsafe.allocateMemory(size); <span class="comment">// 申请内存</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (OutOfMemoryError x) &#123;</span><br><span class="line">        Bits.unreserveMemory(size, cap);</span><br><span class="line">        <span class="keyword">throw</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    unsafe.setMemory(base, size, (<span class="type">byte</span>) <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (pa &amp;&amp; (base % ps != <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="comment">// Round up to page boundary</span></span><br><span class="line">        address = base + ps - (base &amp; (ps - <span class="number">1</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        address = base;</span><br><span class="line">    &#125;</span><br><span class="line">    cleaner = Cleaner.create(<span class="built_in">this</span>, <span class="keyword">new</span> <span class="title class_">Deallocator</span>(base, size, cap)); <span class="comment">// 通过虚引用，来实现直接内存的释放，this为虚引用的实际对象, 第二个参数是一个回调，实现了 runnable 接口，run 方法中通过 unsafe 释放内存。</span></span><br><span class="line">    att = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里调用了一个 <code>Cleaner .create</code> 方法，且后台线程还会对虚引用的对象监测，<em>如果虚引用的实际对象（这里是 DirectByteBuffer ）被回收以后，就会调用 Cleaner 的 clean 方法，来清除直接内存中占用的内存。</em></p>
<p>jvm调优常用参数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+DisableExplicitGC  // 静止显示的 GC</span><br></pre></td></tr></table></figure>

<p>意思就是禁止我们手动的 GC，比如手动 System.gc() 无效，它是一种 full gc，会回收新生代、老年代，会造成程序执行的时间比较长。所以我们就通过 unsafe 对象调用 freeMemory 的方式释放内存。</p>
<hr>
<h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><p><strong>程序计数器、虚拟机栈、本地方法栈</strong>三个区域随线程生灭。这几个区域的内存分配和回收都具备确定性，方法结束、线程结束，自然回收。</p>
<p>Java堆和方法区就有不确定性。只有在运行期间才知道创建哪些对象，分配和回收具有动态性。</p>
<hr>
<h3 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h3><blockquote>
<p><em>本博客不特别记录引用计数法</em></p>
</blockquote>
<p>可作为GC Root的对象</p>
<ul>
<li><p>虚拟机栈（<strong>栈帧中的本地变量表</strong>）中引用的对象，当前正在运行的方法所用到的参数、局部变量、临时变量。</p>
</li>
<li><p>方法区中类<strong>静态</strong>属性引用的对象，如Java类的<strong>引用类型静态变量</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private static User user1；</span><br></pre></td></tr></table></figure>
</li>
<li><p>方法区中<strong>常量</strong>引用的对象，比如字符串常量池（StringTable）里的引用，<strong>final</strong> 修饰。</p>
</li>
<li><p>本地方法栈中 JNI（即一般说的<strong>Native方法</strong>）引用的对象。</p>
</li>
<li><p>Java 虚拟机内部的引用，如基本数据类型对应的 Class 对象，一些常驻的异常对象(比如 NullPointExcepiton、Out Of MemoryError)等，还有系统类加载器。</p>
</li>
<li><p>所有被同步锁(synchronized 关键字)持有的对象。</p>
</li>
<li><p>反映 Java 虚拟机内部情况的 JMXBean、JVMTI 中注册的回调、本地代码缓存等</p>
</li>
</ul>
<hr>
<h3 id="四种引用"><a href="#四种引用" class="headerlink" title="四种引用"></a>四种引用</h3><ul>
<li><p>强引用是最传统的“引用”的定义，是指在程序代码之中<strong>普遍存在</strong>的引用赋值。无论任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object obj=<span class="keyword">new</span> <span class="title class_">Object</span>()</span><br></pre></td></tr></table></figure>
</li>
<li><p>软引用是用来描述一些还有用，但非必须的对象。只被软引用关联着的对象，<u>在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存，才会抛出内存溢出异常。</u>在 JDK 1.2 版之后提供了 <code>SoftReference</code> 类来实现软引用。</p>
</li>
<li><p>弱引用也是用来描述那些非必须对象，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生为止。当垃圾收集器开始工作，<u>无论当前内存是否足够，都会回收掉只被弱引用关联的对象。</u>在 JDK 1.2 版之后提供了 <code>WeakReference</code> 类来实现弱引用。</p>
</li>
<li><p>虚引用也称为“幽灵引用”或者“幻影引用”，它是最弱的一种引用关系。必须配合<strong>引用队列</strong>使用，主要配合 <strong><code>ByteBuffer</code></strong> 使用，被<strong>引用对象回收时</strong>，会将<strong>虚引用</strong>入队， 由 <strong>Reference Handler</strong> 线程调用虚引用相关方法(<code>Unsafe.freeMemory</code>)释放<strong>直接内存</strong>。。在 JDK 1.2 版之后提供了 PhantomReference 类来实现虚引用。</p>
</li>
</ul>
<blockquote>
<p><em>本博客不特别记录finallize()</em></p>
</blockquote>
<hr>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 演示 软引用</span></span><br><span class="line"><span class="comment"> * -Xmx20m -XX:+PrintGCDetails -verbose:gc</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Code_08_SoftReferenceTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">_4MB</span> <span class="operator">=</span> <span class="number">4</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        method2();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置 -Xmx20m , 演示堆内存不足,</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        ArrayList&lt;<span class="type">byte</span>[]&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> <span class="title class_">byte</span>[_4MB]);</span><br><span class="line">        &#125;</span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 演示 软引用</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        ArrayList&lt;SoftReference&lt;<span class="type">byte</span>[]&gt;&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            SoftReference&lt;<span class="type">byte</span>[]&gt; ref = <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">byte</span>[_4MB]);</span><br><span class="line">            System.out.println(ref.get());</span><br><span class="line">            list.add(ref);</span><br><span class="line">            System.out.println(list.size());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;循环结束：&quot;</span> + list.size());</span><br><span class="line">        <span class="keyword">for</span>(SoftReference&lt;<span class="type">byte</span>[]&gt; ref : list) &#123;</span><br><span class="line">            System.out.println(ref.get());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><p>method1 方法解析：<br>首先会设置一个堆内存的大小为 20m，然后运行 mehtod1 方法，会抛异常，堆内存不足，因为 mehtod1 中的 list 都是强引用。</p>
</li>
<li><p>method2 方法解析：<br>在 list 集合中存放了 软引用对象，当内存不足时，会触发 full gc，将软引用的对象回收。</p>
</li>
<li><p>method3方法解析：</p>
<p>当软引用引用的对象被回收了，但是软引用还存在，所以，一般软引用需要搭配一个引用队列一起使用。</p>
</li>
</ul>
<p><strong>关联了引用队列，当软引用所关联的 byte[] 被回收时，软引用自己会加入到 queue 中去</strong></p>
<hr>
<h3 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h3><p>商用虚拟机里，设计者一般至少会把Java堆划为新生代和老年代两区域。</p>
<p>新生代中，每次垃圾收集大批死去，回收少量对象，逐步晋升到老年代存放。</p>
<p>以上是对HotSpot虚拟机。在IBM J9虚拟机中称为婴儿区，长生区。</p>
<h4 id="标记清除算法"><a href="#标记清除算法" class="headerlink" title="标记清除算法"></a><strong>标记清除算法</strong></h4><p>首先标记出所有需要回收的对象，标记完成后统一回收所有被标记的对象。</p>
<p>把对象的起始结束地址放在空闲列表中，分配新对象时去找。</p>
<p>缺点：执行效率不稳定，大量的标记和清除动作。<strong>内存空间碎片化</strong>问题，标记清除后大量不连续的内存碎片。</p>
<h4 id="标记整理算法"><a href="#标记整理算法" class="headerlink" title="标记整理算法"></a>标记整理算法</h4><p>所有存活对象都向内存空间一端移动，然后清理边界以外的内存。</p>
<p>然而必须全程暂停用户应用程序。</p>
<h4 id="标记复制算法"><a href="#标记复制算法" class="headerlink" title="标记复制算法"></a>标记复制算法</h4><p>将内存容量划为相等两部分，当这一块内存用完，就将还活着的对象复制到另一块上面。</p>
<p>运行简单，高效。但空间浪费大。</p>
<p>存活率较高时就要进行多次复制操作，效率低。如果不想浪费50%空间，就要有额外的空间担保，以应对内存中所有对象100%存活的情况。</p>
<hr>
<h3 id="分代垃圾回收"><a href="#分代垃圾回收" class="headerlink" title="分代垃圾回收"></a>分代垃圾回收</h3><p><img src="/filename/6.png"></p>
<ul>
<li>新生代空间不足时，触发 <strong>Minor GC</strong>，伊甸园和 from 存活的对象使用 copy 复制到 to 中，存活的对象年龄加 1并且<strong>交换 from 和to</strong>。</li>
<li>再次创建对象，若新生代的伊甸园(eden space)又满了，则会再次触发 Minor GC（<strong>minor gc 会引发 stop the world</strong>，暂停其它用户的线程，等垃圾回收结束，用户线程才恢复运行），这时不仅会回收伊甸园中的垃圾，还会回收幸存区中的垃圾，再将活跃对象复制到幸存区TO中。回收以后会<strong>交换两个幸存区</strong>，并让幸存区中的对象寿命加1。</li>
<li>当对象寿命超过阈值时，会晋升至老年代，最大寿命是<strong>15</strong>（寿命是保存在每个对象的对象头中，存寿命的部分是4bit）。</li>
<li>当老年代空间不足，会先尝试触发<strong>Minor GC</strong>，如果之后空间仍不足，那么触发 <strong>Full GC</strong>，因为老年代存活率一般比较高，stop the world的时间更长。</li>
<li>都不够就会触发OutOfMermory</li>
</ul>
<hr>
<h2 id="GC分析"><a href="#GC分析" class="headerlink" title="GC分析"></a>GC分析</h2><h3 id="相关vm参数"><a href="#相关vm参数" class="headerlink" title="相关vm参数"></a>相关vm参数</h3><table>
<thead>
<tr>
<th align="center">含义</th>
<th align="center">参数</th>
</tr>
</thead>
<tbody><tr>
<td align="center">堆初始大小</td>
<td align="center">-Xms</td>
</tr>
<tr>
<td align="center">堆最大大小</td>
<td align="center">-Xmx或-XX:MaxHeapSize&#x3D;size</td>
</tr>
<tr>
<td align="center">新生代大小</td>
<td align="center">-Xmn 或 (-XX:NewSize&#x3D;size + -XX:MaxNewSize&#x3D;size )</td>
</tr>
<tr>
<td align="center">幸存区比例（动态）</td>
<td align="center">-XX:SurvivorRatio&#x3D;ratio和-XX:+UseAdaptiveSizepolicy</td>
</tr>
<tr>
<td align="center">幸存区比例</td>
<td align="center">-XX:SurvivorRatio&#x3D;ratio</td>
</tr>
<tr>
<td align="center">晋升阈值</td>
<td align="center">-XX:MaxTenuringThreshold&#x3D;threshold</td>
</tr>
<tr>
<td align="center">晋升详情</td>
<td align="center">-XX:+PrintTenuringDistribution</td>
</tr>
<tr>
<td align="center">GC详情</td>
<td align="center">-XX:+PrintGCDetails -verbose:gc</td>
</tr>
<tr>
<td align="center">FullGC 前 MinorGC</td>
<td align="center">XX:+ScavengeBeforeFullGC</td>
</tr>
</tbody></table>
<p>幸村区比例：如果新生代是10M,当ratio&#x3D;8时，有8M是划给伊甸园的。剩下两等分，分给from和to。</p>
<p>某个线程的内存溢出了而抛异常（out of memory），不会让其他的线程结束运行。这是因为当一个线程<strong>抛出OOM异常后</strong>，<strong>它所占据的内存资源会全部被释放掉</strong>，从而不会影响其他线程的运行，<strong>进程依然正常</strong></p>
<hr>
<h3 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h3><p>Serial收集器–&gt;Parallel–&gt;Concurrent Mark Sweep(CMS)和Garbage First(G1)收集器–&gt;Shenandoah和ZGC</p>
<hr>
<h4 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h4><p>单线程工作的收集器，他在垃圾收集时，必须暂停其他所有工作，直到他完成收集。</p>
<p>新生代采用复制算法，老生代采用标记整理算法。</p>
<p><img src="/filename/9.png"></p>
<hr>
<h4 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a><strong>ParNew收集器</strong></h4><p>是Serial收集器的<strong>多线程并行版本</strong>，除使用多线程外基本与Serial收集器基本一致。目前只有它与CMS收集器配合工作。Parnew收集器是激活CMS后（使用<code>-XX:+UseConcMarkSweepGC</code>)的默认新生代收集器。</p>
<p><img src="/filename/10.png"></p>
<p><strong>开启串行回收器</strong>：新生代**-Serial** ，老年代-<strong>SerialOld</strong> ，vm参数：<code>XX:+UseSerialGC = Serial + SerialOld</code></p>
<p><img src="/filename/5.png"></p>
<p><strong>安全点</strong>：让其他线程都在这个点停下来，以免垃圾回收时移动对象地址，使得其他线程找不到被移动的对象。安全点位置的选取基本上是以“<strong>是否具有让程序长时间执行的特征</strong>”为标准 进行选定的,例如方法调用、循环跳转、异常跳转 等都属于指令序列复用，所以只有具有这些功能的指令才会产生安全点。</p>
<p><strong>阻塞</strong>：因为是串行的，所以只有一个垃圾回收线程。且在该线程执行回收工作时，其他线程进入<strong>阻塞</strong>状态。</p>
<hr>
<h4 id="吞吐量优先-Parallel-Scavenge收集器"><a href="#吞吐量优先-Parallel-Scavenge收集器" class="headerlink" title="吞吐量优先(Parallel Scavenge收集器)"></a>吞吐量优先(Parallel Scavenge收集器)</h4><p>多线程，堆内存较大，多核CPU。单位时间内，STW的时间最短。总时间最短。</p>
<p><strong>开启垃圾回收器</strong>：vm参数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseParallelGC~-XX:+UseParalleOldGC</span><br></pre></td></tr></table></figure>

<p>1.8都默认开启前者代表是新生代的垃圾回收器，使用的是复制算法；后者工作在老年代，采用标记整理算法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:ParallelGCThreads=n</span><br></pre></td></tr></table></figure>

<p>控制ParallelGC运行时的线程数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseAdaptiveSizePolicy</span><br></pre></td></tr></table></figure>

<p>新生代自适应大小调整策略</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:GCTimeRatio=ratio</span><br></pre></td></tr></table></figure>

<p>调节垃圾回收时间和总时间的占比。1&#x2F;(ratio+1)，垃圾回收总时间占比</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:MaxGCPauseMillis=ms</span><br></pre></td></tr></table></figure>

<p>每次垃圾回收最大暂停毫秒数</p>
<p><img src="/filename/7.png"></p>
<hr>
<h4 id="响应时间优先（CMS"><a href="#响应时间优先（CMS" class="headerlink" title="响应时间优先（CMS)"></a>响应时间优先（CMS)</h4><p>多线程，-堆内存较大，多核CPU。尽可能让单次STW时间最短。适用于关注响应速度的服务</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseConcMarkSweepGC-XX:+UseParNewGC~SerialOld</span><br></pre></td></tr></table></figure>

<p>基于标记清除算法的垃圾回收器。</p>
<p>导致过度内存碎片,分配对象时MinorGC不足，老年代也不足，导致并发失败，CMSGC退化为SerialOld，单线程串行的垃圾回收。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:ParallelGCThreads=n~-XX:ConGCThreads=threads</span><br></pre></td></tr></table></figure>

<p>前者：并行的垃圾回收线程数，一般跟cpu核数一样。</p>
<p>后者：并发的垃圾回收线程数，一般设为并行线程数的四分之一。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:CMSInitiatingOccupancyFraction=percent</span><br></pre></td></tr></table></figure>

<p>作用：并发清理的时候会产生新的垃圾，不能等到内存不足了才去清理。要预留空间给浮动垃圾。值设置的越小，触发时机越早。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+CMSScavengeBeforceRemark</span><br></pre></td></tr></table></figure>

<p>作用：在重新标记前对新生代的进行垃圾回收，新生代存活对象少，减轻重新标记压力。（+打开，-关闭）</p>
<p><img src="/filename/8.png"></p>
<p>初始标记只会列举根对象，非常快。用户线程就会恢复运行，垃圾回收线程就会并发标记，把剩余垃圾标记。重新标记再次STW，因为在之前那并发标记期间存在新的引用，影响标记。</p>
<hr>
<h4 id="Young-Colletion跨代引用"><a href="#Young-Colletion跨代引用" class="headerlink" title="Young Colletion跨代引用"></a>Young Colletion跨代引用</h4><p>简单叙述：老年代数据比较多，一个个遍历找跟对象很麻烦，那就把是根的对象的用一张卡记录，记录和新生代的关系，这样新生代中找跟对象就直接查卡，减少找寻的时间</p>
<p>采用了cart table的方式，对老年代进行细分，分成了许多个card,每个card大约是512K。如果老年代某个对象，引用了新生代的对象，我们把这个老年代的对象标记为脏card。脏card不会立即更新，会把更新指令放在queue中。0-0-记忆集可以理解为一种规范，卡表理解为一种具体的实现方式，CMS只有唯一一个卡表（新生代维护），G1每个region都必须有一份卡表</p>
<hr>
<h4 id="并发可达性分析"><a href="#并发可达性分析" class="headerlink" title="并发可达性分析"></a>并发可达性分析</h4><p>产生“对象消失”的问题的两个条件</p>
<ul>
<li>赋值器插入了一条或多条从黑色对象到白色对象的引用。</li>
<li>赋值器删除了全部从灰色对象到该白色对象的直接或间接引用。</li>
</ul>
<p>可以通过<strong>增量更新</strong>（Incremental Update）和<strong>原始快照</strong>（Snapshot At The Beginning，SATB）</p>
<p>增量更新破坏的是第一个条件：当黑色对象插入新的指向白色对象的引用关系时，就将这个新插入的引用记录下来，等并发扫描结束后，再将这些记录过引用关系中的黑色对象为根，重新扫描。可理解为黑色对象插入指向白色对象的饮用后，变为灰色。</p>
<p>原始快照破坏第二个条件：当灰色对象要删除指向白色对象的的引用关系时，将这个要删除的引用记录下来，等并发扫描后，再将这些记录过引用关系的灰色对象为根，重新扫描。</p>
<p>引用关系记录的插入还是删除，虚拟机的记录操作都是通过写屏障是实现的。G1、Shenandoah使用原始快照。</p>
<hr>
<p>写屏障</p>
<p>当灰色对象要删除指向白色对象的的引用关系时，就会触发写屏障机制，将这个要删除的引用记录下来写到本地对象中。然后写进全局队列 </p>
<h4 id="Garbage-First收集器"><a href="#Garbage-First收集器" class="headerlink" title="Garbage First收集器"></a>Garbage First收集器</h4><p>在G1收集器出现之前，包括cms在内，垃圾收集器的目标范围要么是新生代（Minor GC），要么是老年代（Major GC)，要么就是整个java堆（Full GC）。而G1可以面向堆内存的任何部分来组成回收集进行回收，衡量标准不再是它属于哪个分代，而是哪块内存存放垃圾最多，回收收益最大，这就是G1的Mixed GC模式。注意：G1仍遵循分代收集理论。</p>
<p>G1的关键基于Region的堆内存布局。G1把连续的堆内存划分为多个大小相等的独立区域（Region)，每个region都可以根据需要成为Eden，Survivor空间，或者是老年代空间。region还存在一类特殊的Humongous区域，专门存储大对象，G1大多数行为把它当作老年代一部分看待。</p>
<blockquote>
<p><strong>Young Collection–&gt;YoungCollection+Concurrent Mark–&gt;Mixed Collection–&gt;Young Collection</strong></p>
</blockquote>
<p><img src="/1.jpg"></p>
<h6 id="Young-Collection"><a href="#Young-Collection" class="headerlink" title="Young Collection"></a>Young Collection</h6><p>新创建的对象一开始放在Eden区域，当逐渐被占满，触发一次垃圾回收（当然和其他一样有<strong>STW</strong>，但比较短），以<strong>copy的算法</strong>放入幸存区。一定情况下（上面已说明）幸存区会触发垃圾回收（部分进入老年代）</p>
<hr>
<h6 id="YoungCollection-Concurrent-Mark"><a href="#YoungCollection-Concurrent-Mark" class="headerlink" title="YoungCollection+Concurrent Mark"></a>YoungCollection+Concurrent Mark</h6><p>在新生代GC时会进行GC Root的初始标记。</p>
<p>老年代占用堆空间达到阈值时，进行并发标记（no STW），vm参数：     <code>-XX:InitiatingHeapOccupancyPercent=percent</code>。</p>
<hr>
<h6 id="Mixed-Collection"><a href="#Mixed-Collection" class="headerlink" title="Mixed Collection"></a>Mixed Collection</h6><p>并发标记后，老年代也要回收，部分老年会通过复制算法复制到新的老年代区（多少取决于设置的暂停时间<code>-XX:MaxGCPauseMillis=ms</code>)。</p>
<hr>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/default-index/page/2/">2</a><a class="extend next" rel="next" href="/default-index/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">LLCH Liu</p>
  <div class="site-description" itemprop="description">Here we go!!!!</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">12</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">LLCH Liu</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

    <span id="busuanzi_container_site_pv">总访问量<span id="busuanzi_value_site_pv"></span>次</span>
    <span class="post-meta-divider">|</span>
    <span id="busuanzi_container_site_uv">总访客数<span id="busuanzi_value_site_uv"></span>人</span>
    <span class="post-meta-divider">|</span>
<!-- 不蒜子计数初始值纠正 -->
<script>
$(document).ready(function() {

    var int = setInterval(fixCount, 50);  // 50ms周期检测函数
    var countOffset = 20000;  // 初始化首次数据

    function fixCount() {            
       if (document.getElementById("busuanzi_container_site_pv").style.display != "none")
        {
            $("#busuanzi_value_site_pv").html(parseInt($("#busuanzi_value_site_pv").html()) + countOffset); 
            clearInterval(int);
        }                  
        if ($("#busuanzi_container_site_pv").css("display") != "none")
        {
            $("#busuanzi_value_site_uv").html(parseInt($("#busuanzi_value_site_uv").html()) + countOffset); // 加上初始数据 
            clearInterval(int); // 停止检测
        }  
    }
       	
});
</script> 








        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  


</body>
</html>
